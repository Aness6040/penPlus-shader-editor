<!DOCTYPE html>
                    <html lang="en">
                      <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pen+ Shader Editor</title>
    <style>
      body {
        overflow: hidden;

        --CodeVis: hidden;
        --BlocklyVis: visible;

        --EditorTheme_Color_1: #0fbd8c;
        --EditorTheme_Color_2: #0eaa7e;
        --EditorTheme_Color_3: #0c9770;

        --EditorTheme_Theme_1: #0f0f0f;
        --EditorTheme_Theme_2: #141414;
        --EditorTheme_Theme_3: #1f1f1f;
        --EditorTheme_Theme_4: #2f2f2f;

        --EditorTheme_Text_1: #ffffff;
        --EditorTheme_Text_2: #bfbfbf;
        --EditorTheme_Text_3: #ffffff;

        --EditorTheme_TopBarSize: 48px;
      }

      input[type="text"]{
          background-color: var(--EditorTheme_Theme_2);
          font-size: 1rem;
          font-weight: bold;
          border-radius: 4px;
          border-width: 1px;
          border-style: solid;
          border-color: var(--EditorTheme_Theme_3);
          color: var(--EditorTheme_Text_1);
      }

      input[type="checkbox"]{
          appearance: none;
          -webkit-appearance: none;
          width: 20px;
          height: 20px;
          
          background-color: #ffffff;
          border-radius: 5px;
          cursor: pointer;
      }
        
      input[type="checkbox"]:checked{
          background-color: var(--EditorTheme_Color_1);
          /*As a data URL so that we don't have to load it from a url*/
          background-image: url("data:image/svg+xml,%3C!-- https://akaricons.com/ --%3E%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' aria-hidden='true' focusable='false' width='1em' height='1em' style='-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);' preserveAspectRatio='xMidYMid meet' viewBox='0 0 24 24'%3E%3Cg fill='none'%3E%3Cpath d='M4 12l6 6L20 6' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/g%3E%3C/svg%3E");
          background-repeat: no-repeat;
          background-position: center;
      }

      .tempCodePreview {
        background: var(--EditorTheme_Theme_1);
        color: var(--EditorTheme_Text_1);
        width: 70vw;
        height: calc(100vh - var(--EditorTheme_TopBarSize));
        position: absolute;
        left: 30vw;
        top: var(--EditorTheme_TopBarSize);
        resize: none;
        visibility: var(--CodeVis);
        border-radius: 0px;
        border-color: transparent;
      }

      .BlocklyShaderButtons {
        left: 30vw;
        width: 70vw;
        height: var(--EditorTheme_TopBarSize);
        position: absolute;
      }

      .shaderMenu {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: var(--EditorTheme_Theme_1);
        left: 0px;
        top: 0px;
      }

      .buttonSelected {
        background-color: var(--EditorTheme_Color_1);
        border-top-left-radius: 0.5em;
        border-top-right-radius: 0.5em;
        border-bottom-left-radius: 0px;
        border-bottom-right-radius: 0px;
        border-width: 0.25em;
        border-style: solid;
        border-color: var(--EditorTheme_Theme_1);
        top: 0px;
        position: relative;
        height: var(--EditorTheme_TopBarSize);
        margin: 0px;
        color: var(--EditorTheme_Text_1);

        transition: all 250ms;
      }

      .buttonUnselected {
        background-color: var(--EditorTheme_Color_2);
        border-radius: 0.5em;
        border-width: 0.25em;
        border-top-left-radius: 0.5em;
        border-top-right-radius: 0.5em;
        border-bottom-left-radius: 0px;
        border-bottom-right-radius: 0px;
        top: calc(var(--EditorTheme_TopBarSize) / 2.5);
        border-style: solid;
        height: calc(var(--EditorTheme_TopBarSize)/2);
        position: relative;
        border-color: var(--EditorTheme_Theme_1);
        margin: 0px;
        color: var(--EditorTheme_Text_2);

        transition: all 250ms;
      }

      .buttonDisabled {
        background-color: var(--EditorTheme_Theme_4);
        border-radius: 0px;
        border-color: transparent;
        color: var(--EditorTheme_Text_2);
      }

      .previewAndConsole {
        width: 30%;
        height: 100%;
        position: absolute;
        left: 0px;
        top: 0px;
      }

      .shaderpreview {
        width: 100%;
        height: calc(50vh - var(--EditorTheme_TopBarSize));
        position: absolute;
        top: var(--EditorTheme_TopBarSize);
        left: 0px;
        background: var(--EditorTheme_Theme_3);
      }

      .shaderLog {
        position: absolute;
        width: 30vw;
        height: 50vh;
        top: 50vh;
        left: 0px;
        background: var(--EditorTheme_Theme_1);
        overflow-y: scroll;
      }

      .BlocklyDiv {
        width: 70%;
        height: calc(100vh - var(--EditorTheme_TopBarSize));
        left: 30%;
        top: var(--EditorTheme_TopBarSize);
        position: absolute;
        background-color: var(--EditorTheme_Theme_3);
        visibility: var(--BlocklyVis);
      }

      .logText{
        width: 100%;
        height: auto;
        background: var(--EditorTheme_Theme_2);
        color: var(--EditorTheme_Text_1);
      }
      
      .topBar {
        background-color: var(--EditorTheme_Color_1);
        position: absolute;
        width: 100%;
        height: var(--EditorTheme_TopBarSize);
      }

      .Modal {
        width: var(--ModalWidth);
        height: var(--ModalHeight);
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        overflow: hidden;
      }

      .noSelect {
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */
      }
    </style>
  </head>
                      <body>
    <div class="shaderMenu">
      <div class="topBar">
        <div class="previewAndConsole">
          <canvas id="shaderpreview" class="shaderpreview"></canvas>
          <div id="shaderLog" class="shaderLog"></div>
        </div>
        <div class="BlocklyShaderButtons">
          <button class="buttonSelected" id="ButtonBlockly">Scratch</button>
          <button class="buttonUnselected" id="ButtonGLSL">GLSL</button>
        </div>

        <div id="BlocklyDiv" class="BlocklyDiv"></div>
        <textarea id="myBlocklyCodeOutput" class="tempCodePreview" spellcheck="false"></textarea>
      </div>
    </div>
    <div id="popupModal"></div>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <!--Blockly Addons-->
    <!--
    Color Fields, HSV color, continuous toolbox are used.
    Also predefined variables by Hendrik Diel on google groups https://groups.google.com/g/blockly/c/22B9CMXpJpc
  -->
    <script>window.addEventListener("load", () => {
    /**
    @license
    Copyright 2015 Hendrik Diel

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    @fileoverview
    this file enables predefined variables. You can add a variables by calling
    addPredefinedVar(name) and remove by calling removePredefinedVar(name).
    @author
    diel.hendrik@gmail.com (Hendrik Diel)
    */
    (function () {
        Blockly.Variables.predefinedVars = [];
        Blockly.Variables.addPredefiendVar = function (name) {
            Blockly.Variables.predefinedVars.push(name);
        };

        Blockly.Variables.removePredefiendVar = function (name) {
            var index = array.indexOf(name);
            if (index > -1) {
                Blockly.Variables.predefinedVars.splice(index, 1);
            }
        };

        var old = Blockly.Variables.allVariables;
        Blockly.Variables.allVariables = function (root) {
            var vars = old.call(this, root);
            return Blockly.Variables.predefinedVars.concat(vars);
        };
    })();

    //continuousToolbox
    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */

    /**
     * @fileoverview Toolbox category with styling for continuous toolbox.
     */

    /** Toolbox category for continuous toolbox. */
    class ContinuousCategory extends Blockly.ToolboxCategory {
        /**
         * Constructor for ContinuousCategory which is used in ContinuousToolbox.
         * @override
         */
        constructor(categoryDef, toolbox) {
            super(categoryDef, toolbox);
        }

        /** @override */
        createLabelDom_(name) {
            const label = document.createElement("div");
            label.setAttribute("id", this.getId() + ".label");
            label.textContent = name;
            label.classList.add(this.cssConfig_["label"]);
            return label;
        }

        /** @override */
        createIconDom_() {
            const icon = document.createElement("div");
            icon.classList.add("categoryBubble");
            icon.style.backgroundColor = this.colour_;
            return icon;
        }

        /** @override */
        addColourBorder_() {
            // No-op
        }

        /** @override */
        setSelected(isSelected) {
            if (isSelected) {
                this.rowDiv_.style.backgroundColor = "gray";
                Blockly.utils.dom.addClass(
                    this.rowDiv_,
                    this.cssConfig_["selected"]
                );
            } else {
                this.rowDiv_.style.backgroundColor = "";
                Blockly.utils.dom.removeClass(
                    this.rowDiv_,
                    this.cssConfig_["selected"]
                );
            }
            Blockly.utils.aria.setState(
              /** @type {!Element} */(this.htmlDiv_),
                Blockly.utils.aria.State.SELECTED,
                isSelected
            );
        }
    }

    Blockly.registry.register(
        Blockly.registry.Type.TOOLBOX_ITEM,
        Blockly.ToolboxCategory.registrationName,
        ContinuousCategory,
        true
    );
    //continuous flyout
    /**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */

    /**
     * @fileoverview Overrides metrics to exclude the flyout from the viewport.
     */

    /** Computes metrics for a toolbox with an always open flyout. */
    class ContinuousMetrics extends Blockly.MetricsManager {
        /** @override */
        constructor(workspace) {
            super(workspace);
        }
        /**
         * Computes the viewport size to not include the toolbox and the flyout.
         * The default viewport includes the flyout.
         * @override
         */
        getViewMetrics(getWorkspaceCoordinates = undefined) {
            const scale = getWorkspaceCoordinates ? this.workspace_.scale : 1;
            const svgMetrics = this.getSvgMetrics();
            const toolboxMetrics = this.getToolboxMetrics();
            const flyoutMetrics = this.getFlyoutMetrics(false);
            const toolboxPosition = toolboxMetrics.position;

            if (this.workspace_.getToolbox()) {
                // Note: Not actually supported at this time due to ContinunousToolbox
                // only supporting a vertical flyout. But included for completeness.
                if (
                    toolboxPosition == Blockly.TOOLBOX_AT_TOP ||
                    toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM
                ) {
                    svgMetrics.height -=
                        toolboxMetrics.height + flyoutMetrics.height;
                } else if (
                    toolboxPosition == Blockly.TOOLBOX_AT_LEFT ||
                    toolboxPosition == Blockly.TOOLBOX_AT_RIGHT
                ) {
                    svgMetrics.width -= toolboxMetrics.width + flyoutMetrics.width;
                }
            }
            return {
                height: svgMetrics.height / scale,
                width: svgMetrics.width / scale,
                top: -this.workspace_.scrollY / scale,
                left: -this.workspace_.scrollX / scale,
            };
        }

        /**
         * Moves the absoluteLeft and absoluteTop so they no longer include the
         * flyout.
         * @override
         */
        getAbsoluteMetrics() {
            const toolboxMetrics = this.getToolboxMetrics();
            const flyoutMetrics = this.getFlyoutMetrics(false);
            const toolboxPosition = toolboxMetrics.position;
            let absoluteLeft = 0;

            if (
                this.workspace_.getToolbox() &&
                toolboxPosition == Blockly.TOOLBOX_AT_LEFT
            ) {
                absoluteLeft = toolboxMetrics.width + flyoutMetrics.width;
            }
            let absoluteTop = 0;
            if (
                this.workspace_.getToolbox() &&
                toolboxPosition == Blockly.TOOLBOX_AT_TOP
            ) {
                absoluteTop = toolboxMetrics.height + flyoutMetrics.height;
            }
            return {
                top: absoluteTop,
                left: absoluteLeft,
            };
        }
    }

    Blockly.registry.register(
        Blockly.registry.Type.METRICS_MANAGER,
        "CustomMetricsManager",
        ContinuousMetrics
    );

    /**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */

    /** Adds additional padding to the bottom of the flyout if needed. */
    class ContinuousFlyoutMetrics extends Blockly.FlyoutMetricsManager {
        /** @override */
        constructor(workspace, flyout) {
            super(workspace, flyout);
        }
        /**
         * Adds additional padding to the bottom of the flyout if needed,
         * in order to make it possible to scroll to the top of the last category.
         * @override
         */
        getScrollMetrics(
            getWorkspaceCoordinates = undefined,
            cachedViewMetrics = undefined,
            cachedContentMetrics = undefined
        ) {
            const scrollMetrics = super.getScrollMetrics(
                getWorkspaceCoordinates,
                cachedViewMetrics,
                cachedContentMetrics
            );
            const contentMetrics =
                cachedContentMetrics ||
                this.getContentMetrics(getWorkspaceCoordinates);
            const viewMetrics =
                cachedViewMetrics || this.getViewMetrics(getWorkspaceCoordinates);

            if (scrollMetrics) {
                scrollMetrics.height += this.flyout_.calculateBottomPadding(
                    contentMetrics,
                    viewMetrics
                );
            }
            return scrollMetrics;
        }
    }

    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */

    /**
     * @fileoverview Flyout that supports always-open continuous scrolling.
     */

    /**
     * Class for continuous flyout.
     */
    class ContinuousFlyout extends Blockly.VerticalFlyout {
        /** @override */
        constructor(workspaceOptions) {
            super(workspaceOptions);

            /**
             * List of scroll positions for each category.
             * @type {!Array<{name: string, position: !Object}>}
             */
            this.scrollPositions = [];

            /**
             * Target scroll position, used to smoothly scroll to a given category
             * location when selected.
             * @type {?number}
             */
            this.scrollTarget = null;

            /**
             * The percentage of the distance to the scrollTarget that should be
             * scrolled at a time. Lower values will produce a smoother, slower scroll.
             * @type {number}
             */
            this.scrollAnimationFraction = 0.3;

            /**
             * Whether to recycle blocks when refreshing the flyout. When false, do not
             * allow anything to be recycled. The default is to recycle.
             * @type {boolean}
             * @private
             */
            this.recyclingEnabled_ = true;

            this.workspace_.setMetricsManager(
                new ContinuousFlyoutMetrics(this.workspace_, this)
            );

            this.workspace_.addChangeListener((e) => {
                if (e.type === Blockly.Events.VIEWPORT_CHANGE) {
                    this.selectCategoryByScrollPosition_(-this.workspace_.scrollY);
                }
            });

            this.autoClose = false;
        }

        /**
         * Gets parent toolbox.
         * Since we registered the ContinuousToolbox, we know that's its type.
         * @returns {!ContinuousToolbox} Toolbox that owns this flyout.
         * @private
         */
        getParentToolbox_() {
            const toolbox = this.targetWorkspace.getToolbox();
            return /** @type {!ContinuousToolbox} */ (toolbox);
        }

        /**
         * Records scroll position for each category in the toolbox.
         * The scroll position is determined by the coordinates of each category's
         * label after the entire flyout has been rendered.
         * @package
         */
        recordScrollPositions() {
            this.scrollPositions = [];
            const categoryLabels = this.buttons_.filter(
                (button) =>
                    button.isLabel() &&
                    this.getParentToolbox_().getCategoryByName(
                        button.getButtonText()
                    )
            );
            for (const button of categoryLabels) {
                if (button.isLabel()) {
                    this.scrollPositions.push({
                        name: button.getButtonText(),
                        position: button.getPosition(),
                    });
                }
            }
        }

        /**
         * Returns the scroll position for the given category name.
         * @param {string} name Category name.
         * @returns {?Object} Scroll position for given category, or null if not
         *     found.
         * @package
         */
        getCategoryScrollPosition(name) {
            for (const scrollInfo of this.scrollPositions) {
                if (scrollInfo.name === name) {
                    return scrollInfo.position;
                }
            }
            console.warn(`Scroll position not recorded for category ${name}`);
            return null;
        }

        /**
         * Selects an item in the toolbox based on the scroll position of the flyout.
         * @param {number} position Current scroll position of the workspace.
         * @private
         */
        selectCategoryByScrollPosition_(position) {
            // If we are currently auto-scrolling, due to selecting a category by
            // clicking on it, do not update the category selection.
            if (this.scrollTarget) {
                return;
            }
            const scaledPosition = Math.round(position / this.workspace_.scale);
            // Traverse the array of scroll positions in reverse, so we can select the
            // furthest category that the scroll position is beyond.
            for (let i = this.scrollPositions.length - 1; i >= 0; i--) {
                const category = this.scrollPositions[i];
                if (scaledPosition >= category.position.y) {
                    this.getParentToolbox_().selectCategoryByName(category.name);
                    return;
                }
            }
        }

        /**
         * Scrolls flyout to given position.
         * @param {number} position The x coordinate to scroll to.
         */
        scrollTo(position) {
            // Set the scroll target to either the scaled position or the lowest
            // possible scroll point, whichever is smaller.
            const metrics = this.workspace_.getMetrics();
            this.scrollTarget = Math.min(
                position * this.workspace_.scale,
                metrics.scrollHeight - metrics.viewHeight
            );

            this.stepScrollAnimation_();
        }

        /**
         * Step the scrolling animation by scrolling a fraction of the way to
         * a scroll target, and request the next frame if necessary.
         * @private
         */
        stepScrollAnimation_() {
            if (!this.scrollTarget) {
                return;
            }

            const currentScrollPos = -this.workspace_.scrollY;
            const diff = this.scrollTarget - currentScrollPos;
            if (Math.abs(diff) < 1) {
                this.workspace_.scrollbar.setY(this.scrollTarget);
                this.scrollTarget = null;
                return;
            }
            this.workspace_.scrollbar.setY(
                currentScrollPos + diff * this.scrollAnimationFraction
            );

            requestAnimationFrame(this.stepScrollAnimation_.bind(this));
        }

        /**
         * Add additional padding to the bottom of the flyout if needed,
         * in order to make it possible to scroll to the top of the last category.
         * @param {!Blockly.MetricsManager.ContainerRegion} contentMetrics Content
         *    metrics for the flyout.
         * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics
         *    for the flyout.
         * @returns {number} Additional bottom padding.
         */
        calculateBottomPadding(contentMetrics, viewMetrics) {
            if (this.scrollPositions.length > 0) {
                const lastCategory =
                    this.scrollPositions[this.scrollPositions.length - 1];
                const lastPosition =
                    lastCategory.position.y * this.workspace_.scale;
                const lastCategoryHeight = contentMetrics.height - lastPosition;
                if (lastCategoryHeight < viewMetrics.height) {
                    return viewMetrics.height - lastCategoryHeight;
                }
            }
            return 0;
        }

        /** @override */
        getX() {
            if (
                this.isVisible() &&
                this.targetWorkspace.toolboxPosition === this.toolboxPosition_ &&
                this.targetWorkspace.getToolbox() &&
                this.toolboxPosition_ !== Blockly.utils.toolbox.Position.LEFT
            ) {
                // This makes it so blocks cannot go under the flyout in RTL mode.
                return this.targetWorkspace.getMetricsManager().getViewMetrics()
                    .width;
            }

            return super.getX();
        }

        /**
         * @override
         */
        show(flyoutDef) {
            super.show(flyoutDef);
            this.recordScrollPositions();
            this.workspace_.resizeContents();
        }

        /**
         * Determine if this block can be recycled in the flyout.  Blocks that have no
         * variables and are not dynamic shadows can be recycled.
         * @param {!Blockly.BlockSvg} block The block to attempt to recycle.
         * @returns {boolean} True if the block can be recycled.
         * @protected
         */
        blockIsRecyclable_(block) {
            if (!this.recyclingEnabled_) {
                return false;
            }

            // If the block needs to parse mutations, never recycle.
            if (block.mutationToDom && block.domToMutation) {
                return false;
            }

            if (!block.isEnabled()) {
                return false;
            }

            for (const input of block.inputList) {
                for (const field of input.fieldRow) {
                    // No variables.
                    if (field instanceof Blockly.FieldVariable) {
                        return false;
                    }
                    if (field instanceof Blockly.FieldDropdown) {
                        if (field.isOptionListDynamic()) {
                            return false;
                        }
                    }
                }
                // Check children.
                if (input.connection) {
                    const targetBlock =
                        /** @type {Blockly.BlockSvg} */
                        (input.connection.targetBlock());
                    if (targetBlock && !this.blockIsRecyclable_(targetBlock)) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * Sets the function used to determine whether a block is recyclable.
         * @param {function(!Blockly.BlockSvg):boolean} func The function used to
         *     determine if a block is recyclable.
         * @public
         */
        setBlockIsRecyclable(func) {
            this.blockIsRecyclable_ = func;
        }

        /**
         * Set whether the flyout can recycle blocks.
         * @param {boolean} isEnabled True to allow blocks to be recycled, false
         *     otherwise.
         * @public
         */
        setRecyclingEnabled(isEnabled) {
            this.recyclingEnabled_ = isEnabled;
        }
    }

    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */

    /**
     * @fileoverview Toolbox that uses a continuous scrolling flyout.
     */

    /**
     * Class for continuous toolbox.
     */
    class ContinuousToolbox extends Blockly.Toolbox {
        /** @override */
        constructor(workspace) {
            super(workspace);
        }

        /** @override */
        init() {
            super.init();

            // Populate the flyout with all blocks and show it immediately.
            const flyout = this.getFlyout();
            flyout.show(this.getInitialFlyoutContents_());
            flyout.recordScrollPositions();

            this.workspace_.addChangeListener((e) => {
                if (
                    e.type === Blockly.Events.BLOCK_CREATE ||
                    e.type === Blockly.Events.BLOCK_DELETE
                ) {
                    this.refreshSelection();
                }
            });
        }

        /** @override */
        getFlyout() {
            return /** @type {ContinuousFlyout} */ (super.getFlyout());
        }

        /**
         * Gets the contents that should be shown in the flyout immediately.
         * This includes all blocks and labels for each category of block.
         * @returns {!Blockly.utils.toolbox.FlyoutItemInfoArray} Flyout contents.
         * @private
         */
        getInitialFlyoutContents_() {
            /** @type {!Blockly.utils.toolbox.FlyoutItemInfoArray} */
            let contents = [];
            for (const toolboxItem of this.contents_) {
                if (toolboxItem instanceof Blockly.ToolboxCategory) {
                    // Create a label node to go at the top of the category
                    contents.push({ kind: "LABEL", text: toolboxItem.getName() });
                    /**
                     * @type {string|Blockly.utils.toolbox.FlyoutItemInfoArray|
                     *    Blockly.utils.toolbox.FlyoutItemInfo}
                     */
                    let itemContents = toolboxItem.getContents();

                    // Handle custom categories (e.g. variables and functions)
                    if (typeof itemContents === "string") {
                        itemContents =
                    /** @type {!Blockly.utils.toolbox.DynamicCategoryInfo} */ ({
                                custom: itemContents,
                                kind: "CATEGORY",
                            });
                    }
                    contents = contents.concat(itemContents);
                }
            }
            return contents;
        }

        /** @override */
        refreshSelection() {
            this.getFlyout().show(this.getInitialFlyoutContents_());
        }

        /** @override */
        updateFlyout_(_oldItem, newItem) {
            if (newItem) {
                const target = this.getFlyout().getCategoryScrollPosition(
                    newItem.name_
                ).y;
                this.getFlyout().scrollTo(target);
            }
        }

        /** @override */
        shouldDeselectItem_(oldItem, newItem) {
            // Should not deselect if the same category is clicked again.
            return oldItem && oldItem !== newItem;
        }

        /**
         * Gets a category by name.
         * @param {string} name Name of category to get.
         * @returns {?Blockly.ToolboxCategory} Category, or null if not
         *    found.
         * @package
         */
        getCategoryByName(name) {
            const category = this.contents_.find(
                (item) =>
                    item instanceof Blockly.ToolboxCategory &&
                    item.isSelectable() &&
                    name === item.getName()
            );
            if (category) {
                return /** @type {!Blockly.ToolboxCategory} */ (category);
            }
            return null;
        }

        /**
         * Selects the category with the given name.
         * Similar to setSelectedItem, but importantly, does not call updateFlyout
         * because this is called while the flyout is being scrolled.
         * @param {string} name Name of category to select.
         * @package
         */
        selectCategoryByName(name) {
            const newItem = this.getCategoryByName(name);
            if (!newItem) {
                return;
            }
            const oldItem = this.selectedItem_;

            if (this.shouldDeselectItem_(oldItem, newItem)) {
                this.deselectItem_(oldItem);
            }

            if (this.shouldSelectItem_(oldItem, newItem)) {
                this.selectItem_(oldItem, newItem);
            }
        }

        /** @override */
        getClientRect() {
            // If the flyout never closes, it should be the deletable area.
            const flyout = this.getFlyout();
            if (flyout && !flyout.autoClose) {
                return flyout.getClientRect();
            }
            return super.getClientRect();
        }
    }

    Blockly.Css.register(`
.categoryBubble {
  margin: 0 auto 0.125rem;
  border-radius: 100%;
  border: 1px solid;
  width: 1.25rem;
  height: 1.25rem;
}
.blocklyTreeRow {
  height: initial;
  padding: 3px 0;
}
.blocklyTreeRowContentContainer {
  display: flex;
  flex-direction: column;
}
.blocklyTreeLabel {
  margin: auto;
}
`);
    //Disable Orphans
    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */

    /**
     * This plugin changes the logic of the enable/disable context menu item. It is
     * enabled for all blocks except top-level blocks that have output or
     * previous connections. In other words, the option is disabled for orphan
     * blocks. Using this plugin allows users to disable valid non-orphan blocks,
     * but not re-enable blocks that have been automatically disabled by
     * `disableOrphans`.
     */
    class DisableTopBlocks {
        /**
         * Modifies the context menu 'disable' option as described above.
         */
        init() {
            const disableMenuItem =
                Blockly.ContextMenuRegistry.registry.getItem("blockDisable");
            this.oldPreconditionFn = disableMenuItem.preconditionFn;
            disableMenuItem.preconditionFn = function (
              /** @type {!Blockly.ContextMenuRegistry.Scope} */ scope
            ) {
                const block = scope.block;
                if (
                    !block.isInFlyout &&
                    block.workspace.options.disable &&
                    block.isEditable()
                ) {
                    if (block.getInheritedDisabled() || isOrphan(block)) {
                        return "disabled";
                    }
                    return "enabled";
                }
                return "hidden";
            };
        }

        /**
         * Turn off the effects of this plugin and restore the initial behavior.
         * This is never required to be called. It is optional in case you need to
         * disable the plugin.
         */
        dispose() {
            const disableMenuItem =
                Blockly.ContextMenuRegistry.registry.getItem("blockDisable");
            disableMenuItem.preconditionFn = this.oldPreconditionFn;
        }
    }

    /**
     * A block is an orphan if its parent is an orphan, or if it doesn't have a
     * parent but it does have a previous or output connection (so it expects to be
     * attached to something). This means all children of orphan blocks are also
     * orphans and cannot be manually re-enabled.
     * @param {!Blockly.BlockSvg} block Block to check.
     * @returns {boolean} Whether the block is an orphan.
     */
    function isOrphan(block) {
        // If the parent is an orphan block, this block should also be considered
        // an orphan so it cannot be manually re-enabled.
        const parent = /** @type {Blockly.BlockSvg} */ (block.getParent());
        if (parent && isOrphan(parent)) {
            return true;
        }
        return (
            !parent && !!(block.outputConnection || block.previousConnection)
        );
    }
    //Colour Fields
    /**
     * @license
     * Copyright 2023 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @fileoverview Colour input field.
     */
    /**
     * Class for a colour input field.
     */
    class FieldColour extends Blockly.Field {
        /**
         * @param value The initial value of the field.  Should be in '#rrggbb'
         *     format.  Defaults to the first value in the default colour array.  Also
         *     accepts Field.SKIP_SETUP if you wish to skip setup (only used by
         *     subclasses that want to handle configuration and setting the field
         *     value after their own constructors have run).
         * @param validator A function that is called to validate changes to the
         *     field's value.  Takes in a colour string & returns a validated colour
         *     string ('#rrggbb' format), or null to abort the change.
         * @param config A map of options used to configure the field.
         *     See the [field creation documentation]{@link
         * https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/colour}
         * for a list of properties this parameter supports.
         */
        constructor(value, validator, config) {
            super(Blockly.Field.SKIP_SETUP);
            /** The field's colour picker element. */
            this.picker = null;
            /** Index of the currently highlighted element. */
            this.highlightedIndex = null;
            /**
             * Array holding info needed to unbind events.
             * Used for disposing.
             * Ex: [[node, name, func], [node, name, func]].
             */
            this.boundEvents = [];
            /**
             * Serializable fields are saved by the serializer, non-serializable fields
             * are not.  Editable fields should also be serializable.
             */
            this.SERIALIZABLE = true;
            /** Mouse cursor style when over the hotspot that initiates the editor. */
            this.CURSOR = "default";
            /**
             * Used to tell if the field needs to be rendered the next time the block is
             * rendered.  Colour fields are statically sized, and only need to be
             * rendered at initialization.
             */
            // eslint-disable-next-line @typescript-eslint/naming-convention
            this.isDirty_ = false;
            /**
             * An array of colour strings for the palette.
             * Copied from goog.ui.ColorPicker.SIMPLE_GRID_COLORS
             */
            this.colours = [
                // grays
                "#ffffff",
                "#cccccc",
                "#c0c0c0",
                "#999999",
                "#666666",
                "#333333",
                "#000000",
                // reds
                "#ffcccc",
                "#ff6666",
                "#ff0000",
                "#cc0000",
                "#990000",
                "#660000",
                "#330000",
                // oranges
                "#ffcc99",
                "#ff9966",
                "#ff9900",
                "#ff6600",
                "#cc6600",
                "#993300",
                "#663300",
                // yellows
                "#ffff99",
                "#ffff66",
                "#ffcc66",
                "#ffcc33",
                "#cc9933",
                "#996633",
                "#663333",
                // olives
                "#ffffcc",
                "#ffff33",
                "#ffff00",
                "#ffcc00",
                "#999900",
                "#666600",
                "#333300",
                // greens
                "#99ff99",
                "#66ff99",
                "#33ff33",
                "#33cc00",
                "#009900",
                "#006600",
                "#003300",
                // turquoises
                "#99ffff",
                "#33ffff",
                "#66cccc",
                "#00cccc",
                "#339999",
                "#336666",
                "#003333",
                // blues
                "#ccffff",
                "#66ffff",
                "#33ccff",
                "#3366ff",
                "#3333ff",
                "#000099",
                "#000066",
                // purples
                "#ccccff",
                "#9999ff",
                "#6666cc",
                "#6633ff",
                "#6600cc",
                "#333399",
                "#330099",
                // violets
                "#ffccff",
                "#ff99ff",
                "#cc66cc",
                "#cc33cc",
                "#993399",
                "#663366",
                "#330033",
            ];
            /**
             * An array of tooltip strings for the palette.  If not the same length as
             * COLOURS, the colour's hex code will be used for any missing titles.
             */
            this.titles = [];
            /**
             * Number of columns in the palette.
             */
            this.columns = 7;
            if (value === Blockly.Field.SKIP_SETUP) return;
            if (config) {
                this.configure_(config);
            }
            this.setValue(value);
            if (validator) {
                this.setValidator(validator);
            }
        }
        /**
         * Configure the field based on the given map of options.
         *
         * @param config A map of options to configure the field based on.
         */
        // eslint-disable-next-line @typescript-eslint/naming-convention
        configure_(config) {
            super.configure_(config);
            if (config.colourOptions) this.colours = config.colourOptions;
            if (config.colourTitles) this.titles = config.colourTitles;
            if (config.columns) this.columns = config.columns;
        }
        /**
         * Create the block UI for this colour field.
         *
         * @internal
         */
        initView() {
            const constants = this.getConstants();
            // This can't happen, but TypeScript thinks it can and lint forbids `!.`.
            if (!constants) throw Error("Constants not found");
            this.size_ = new Blockly.utils.Size(
                constants.FIELD_COLOUR_DEFAULT_WIDTH,
                constants.FIELD_COLOUR_DEFAULT_HEIGHT
            );
            if (!constants.FIELD_COLOUR_FULL_BLOCK) {
                this.createBorderRect_();
                this.getBorderRect().style["fillOpacity"] = "1";
            } else if (this.sourceBlock_ instanceof Blockly.BlockSvg) {
                this.clickTarget_ = this.sourceBlock_.getSvgRoot();
            }
        }
        /**
         * Updates text field to match the colour/style of the block.
         *
         * @internal
         */
        applyColour() {
            const constants = this.getConstants();
            // This can't happen, but TypeScript thinks it can and lint forbids `!.`.
            if (!constants) throw Error("Constants not found");
            if (!constants.FIELD_COLOUR_FULL_BLOCK) {
                if (this.borderRect_) {
                    this.borderRect_.style.fill = this.getValue();
                }
            } else if (this.sourceBlock_ instanceof Blockly.BlockSvg) {
                this.sourceBlock_.pathObject.svgPath.setAttribute(
                    "fill",
                    this.getValue()
                );
                this.sourceBlock_.pathObject.svgPath.setAttribute(
                    "stroke",
                    "#fff"
                );
            }
        }
        /**
         * Ensure that the input value is a valid colour.
         *
         * @param newValue The input value.
         * @returns A valid colour, or null if invalid.
         */
        // eslint-disable-next-line @typescript-eslint/naming-convention
        doClassValidation_(newValue) {
            if (typeof newValue !== "string") {
                return null;
            }
            return Blockly.utils.colour.parse(newValue);
        }
        /**
         * Update the value of this colour field, and update the displayed colour.
         *
         * @param newValue The value to be saved.  The default validator guarantees
         *     that this is a colour in '#rrggbb' format.
         */
        // eslint-disable-next-line @typescript-eslint/naming-convention
        doValueUpdate_(newValue) {
            this.value_ = newValue;
            if (this.borderRect_) {
                this.borderRect_.style.fill = newValue;
            } else if (
                this.sourceBlock_ &&
                this.sourceBlock_.rendered &&
                this.sourceBlock_ instanceof Blockly.BlockSvg
            ) {
                this.sourceBlock_.pathObject.svgPath.setAttribute(
                    "fill",
                    newValue
                );
                this.sourceBlock_.pathObject.svgPath.setAttribute(
                    "stroke",
                    "#fff"
                );
            }
        }
        /**
         * Get the text for this field.  Used when the block is collapsed.
         *
         * @returns Text representing the value of this field.
         */
        getText() {
            let colour = this.value_;
            // Try to use #rgb format if possible, rather than #rrggbb.
            if (/^#(.)\1(.)\2(.)\3$/.test(colour)) {
                colour = "#" + colour[1] + colour[3] + colour[5];
            }
            return colour;
        }
        /**
         * Set a custom colour grid for this field.
         *
         * @param colours Array of colours for this block, or null to use default
         *     (FieldColour.COLOURS).
         * @param titles Optional array of colour tooltips, or null to use default
         *     (FieldColour.TITLES).
         * @returns Returns itself (for method chaining).
         */
        setColours(colours, titles) {
            this.colours = colours;
            if (titles) {
                this.titles = titles;
            }
            return this;
        }
        /**
         * Set a custom grid size for this field.
         *
         * @param columns Number of columns for this block, or 0 to use default
         *     (FieldColour.COLUMNS).
         * @returns Returns itself (for method chaining).
         */
        setColumns(columns) {
            this.columns = columns;
            return this;
        }
        /** Create and show the colour field's editor. */
        // eslint-disable-next-line @typescript-eslint/naming-convention
        showEditor_() {
            this.dropdownCreate();
            // This can't happen, but TypeScript thinks it can and lint forbids `!.`.
            if (!this.picker) throw Error("Picker not found");
            Blockly.DropDownDiv.getContentDiv().appendChild(this.picker);
            Blockly.DropDownDiv.showPositionedByField(
                this,
                this.dropdownDispose.bind(this)
            );
            // Focus so we can start receiving keyboard events.
            this.picker.focus({ preventScroll: true });
        }
        /**
         * Handle a click on a colour cell.
         *
         * @param e Mouse event.
         */
        onClick(e) {
            const cell = e.target;
            const colour = cell && cell.getAttribute("data-colour");
            if (colour !== null) {
                this.setValue(colour);
                Blockly.DropDownDiv.hideIfOwner(this);
            }
        }
        /**
         * Handle a key down event.  Navigate around the grid with the
         * arrow keys.  Enter selects the highlighted colour.
         *
         * @param e Keyboard event.
         */
        onKeyDown(e) {
            let handled = true;
            let highlighted;
            switch (e.key) {
                case "ArrowUp":
                    this.moveHighlightBy(0, -1);
                    break;
                case "ArrowDown":
                    this.moveHighlightBy(0, 1);
                    break;
                case "ArrowLeft":
                    this.moveHighlightBy(-1, 0);
                    break;
                case "ArrowRight":
                    this.moveHighlightBy(1, 0);
                    break;
                case "Enter":
                    // Select the highlighted colour.
                    highlighted = this.getHighlighted();
                    if (highlighted) {
                        const colour = highlighted.getAttribute("data-colour");
                        if (colour !== null) {
                            this.setValue(colour);
                        }
                    }
                    Blockly.DropDownDiv.hideWithoutAnimation();
                    break;
                default:
                    handled = false;
            }
            if (handled) {
                e.stopPropagation();
            }
        }
        /**
         * Move the currently highlighted position by dx and dy.
         *
         * @param dx Change of x.
         * @param dy Change of y.
         */
        moveHighlightBy(dx, dy) {
            if (!this.highlightedIndex) {
                return;
            }
            const colours = this.colours;
            const columns = this.columns;
            // Get the current x and y coordinates.
            let x = this.highlightedIndex % columns;
            let y = Math.floor(this.highlightedIndex / columns);
            // Add the offset.
            x += dx;
            y += dy;
            if (dx < 0) {
                // Move left one grid cell, even in RTL.
                // Loop back to the end of the previous row if we have room.
                if (x < 0 && y > 0) {
                    x = columns - 1;
                    y--;
                } else if (x < 0) {
                    x = 0;
                }
            } else if (dx > 0) {
                // Move right one grid cell, even in RTL.
                // Loop to the start of the next row, if there's room.
                if (
                    x > columns - 1 &&
                    y < Math.floor(colours.length / columns) - 1
                ) {
                    x = 0;
                    y++;
                } else if (x > columns - 1) {
                    x--;
                }
            } else if (dy < 0) {
                // Move up one grid cell, stop at the top.
                if (y < 0) {
                    y = 0;
                }
            } else if (dy > 0) {
                // Move down one grid cell, stop at the bottom.
                if (y > Math.floor(colours.length / columns) - 1) {
                    y = Math.floor(colours.length / columns) - 1;
                }
            }
            // Move the highlight to the new coordinates.
            const cell = this.picker.childNodes[y].childNodes[x];
            const index = y * columns + x;
            this.setHighlightedCell(cell, index);
        }
        /**
         * Handle a mouse move event.  Highlight the hovered colour.
         *
         * @param e Mouse event.
         */
        onMouseMove(e) {
            const cell = e.target;
            const index = cell && Number(cell.getAttribute("data-index"));
            if (index !== null && index !== this.highlightedIndex) {
                this.setHighlightedCell(cell, index);
            }
        }
        /** Handle a mouse enter event.  Focus the picker. */
        onMouseEnter() {
            var _a;
            (_a = this.picker) === null || _a === void 0
                ? void 0
                : _a.focus({ preventScroll: true });
        }
        /**
         * Handle a mouse leave event.  Blur the picker and unhighlight
         * the currently highlighted colour.
         */
        onMouseLeave() {
            var _a;
            (_a = this.picker) === null || _a === void 0 ? void 0 : _a.blur();
            const highlighted = this.getHighlighted();
            if (highlighted) {
                Blockly.utils.dom.removeClass(
                    highlighted,
                    "blocklyColourHighlighted"
                );
            }
        }
        /**
         * Returns the currently highlighted item (if any).
         *
         * @returns Highlighted item (null if none).
         */
        getHighlighted() {
            var _a;
            if (!this.highlightedIndex) {
                return null;
            }
            const x = this.highlightedIndex % this.columns;
            const y = Math.floor(this.highlightedIndex / this.columns);
            const row =
                (_a = this.picker) === null || _a === void 0
                    ? void 0
                    : _a.childNodes[y];
            if (!row) {
                return null;
            }
            return row.childNodes[x];
        }
        /**
         * Update the currently highlighted cell.
         *
         * @param cell The new cell to highlight.
         * @param index The index of the new cell.
         */
        setHighlightedCell(cell, index) {
            // Unhighlight the current item.
            const highlighted = this.getHighlighted();
            if (highlighted) {
                Blockly.utils.dom.removeClass(
                    highlighted,
                    "blocklyColourHighlighted"
                );
            }
            // Highlight new item.
            Blockly.utils.dom.addClass(cell, "blocklyColourHighlighted");
            // Set new highlighted index.
            this.highlightedIndex = index;
            // Update accessibility roles.
            const cellId = cell.getAttribute("id");
            if (cellId && this.picker) {
                Blockly.utils.aria.setState(
                    this.picker,
                    Blockly.utils.aria.State.ACTIVEDESCENDANT,
                    cellId
                );
            }
        }
        /** Create a colour picker dropdown editor. */
        dropdownCreate() {
            const columns = this.columns;
            const colours = this.colours;
            const selectedColour = this.getValue();
            // Create the palette.
            const table = document.createElement("table");
            table.className = "blocklyColourTable";
            table.tabIndex = 0;
            table.dir = "ltr";
            Blockly.utils.aria.setRole(table, Blockly.utils.aria.Role.GRID);
            Blockly.utils.aria.setState(
                table,
                Blockly.utils.aria.State.EXPANDED,
                true
            );
            Blockly.utils.aria.setState(
                table,
                Blockly.utils.aria.State.ROWCOUNT,
                Math.floor(colours.length / columns)
            );
            Blockly.utils.aria.setState(
                table,
                Blockly.utils.aria.State.COLCOUNT,
                columns
            );
            let row = null;
            for (let i = 0; i < colours.length; i++) {
                if (i % columns === 0) {
                    row = document.createElement("tr");
                    Blockly.utils.aria.setRole(row, Blockly.utils.aria.Role.ROW);
                    table.appendChild(row);
                }
                const cell = document.createElement("td");
                row.appendChild(cell);
                // This becomes the value, if clicked.
                cell.setAttribute("data-colour", colours[i]);
                cell.title = this.titles[i] || colours[i];
                cell.id = Blockly.utils.idGenerator.getNextUniqueId();
                cell.setAttribute("data-index", `${i}`);
                Blockly.utils.aria.setRole(
                    cell,
                    Blockly.utils.aria.Role.GRIDCELL
                );
                Blockly.utils.aria.setState(
                    cell,
                    Blockly.utils.aria.State.LABEL,
                    colours[i]
                );
                Blockly.utils.aria.setState(
                    cell,
                    Blockly.utils.aria.State.SELECTED,
                    colours[i] === selectedColour
                );
                cell.style.backgroundColor = colours[i];
                if (colours[i] === selectedColour) {
                    cell.className = "blocklyColourSelected";
                    this.highlightedIndex = i;
                }
            }
            // Configure event handler on the table to listen for any event in a cell.
            this.boundEvents.push(
                Blockly.browserEvents.conditionalBind(
                    table,
                    "pointerdown",
                    this,
                    this.onClick,
                    true
                )
            );
            this.boundEvents.push(
                Blockly.browserEvents.conditionalBind(
                    table,
                    "pointermove",
                    this,
                    this.onMouseMove,
                    true
                )
            );
            this.boundEvents.push(
                Blockly.browserEvents.conditionalBind(
                    table,
                    "pointerenter",
                    this,
                    this.onMouseEnter,
                    true
                )
            );
            this.boundEvents.push(
                Blockly.browserEvents.conditionalBind(
                    table,
                    "pointerleave",
                    this,
                    this.onMouseLeave,
                    true
                )
            );
            this.boundEvents.push(
                Blockly.browserEvents.conditionalBind(
                    table,
                    "keydown",
                    this,
                    this.onKeyDown,
                    false
                )
            );
            this.picker = table;
        }
        /** Disposes of events and DOM-references belonging to the colour editor. */
        dropdownDispose() {
            for (const event of this.boundEvents) {
                Blockly.browserEvents.unbind(event);
            }
            this.boundEvents.length = 0;
            this.picker = null;
            this.highlightedIndex = null;
        }
        /**
         * Construct a FieldColour from a JSON arg object.
         *
         * @param options A JSON object with options (colour).
         * @returns The new field instance.
         * @nocollapse
         * @internal
         */
        static fromJson(options) {
            // `this` might be a subclass of FieldColour if that class doesn't override
            // the static fromJson method.
            return new this(options.colour, undefined, options);
        }
    }
    /** The default value for this field. */
    FieldColour.prototype.DEFAULT_VALUE = "#ffffff";
    // Unregister legacy field_colour that was in core.  Delete this once
    // core Blockly no longer defines field_colour.
    // If field_colour is not defined in core, this generates a console warning.
    Blockly.fieldRegistry.unregister("field_colour");
    Blockly.fieldRegistry.register("field_colour", FieldColour);
    /**
     * CSS for colour picker.
     */
    Blockly.Css.register(`
    .blocklyColourTable {
      border-collapse: collapse;
      display: block;
      outline: none;
      padding: 1px;
    }

    .blocklyColourTable>tr>td {
      border: 0.5px solid #888;
      box-sizing: border-box;
      cursor: pointer;
      display: inline-block;
      height: 20px;
      padding: 0;
      width: 20px;
    }

    .blocklyColourTable>tr>td.blocklyColourHighlighted {
      border-color: #eee;
      box-shadow: 2px 2px 7px 2px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .blocklyColourSelected, .blocklyColourSelected:hover {
      border-color: #eee !important;
      outline: 1px solid #333;
      position: relative;
    }
    `);

    //HSV colour fields
    /**
     * A structure with three properties r, g, and b, representing the amount of
     * red, green, and blue light in the sRGB colour space where 1 is the maximum
     * amount of light that can be displayed.
     */
    class RgbColour {
        /**
         * The RgbColour constructor.
         * @param r The initial amount of red. Defaults to 0.
         * @param g The initial amount of green. Defaults to 0.
         * @param b The initial amount of blue. Defaults to 0.
         */
        constructor(r = 0, g = 0, b = 0) {
            this.r = r;
            this.g = g;
            this.b = b;
        }

        /**
         * Given a number from 0 to 1, returns a two-digit hexadecimal string from
         * '00' to 'ff'.
         * @param x The amount of light in a component from 0 to 1.
         * @returns A hexadecimal representation from '00' to 'ff'.
         */
        static componentToHex(x) {
            if (x <= 0) return "00";
            if (x >= 1) return "ff";
            return ("0" + ((x * 255 + 0.5) >>> 0).toString(16)).slice(-2);
        }

        /**
         * Returns a hexadecimal string in the format #rrggbb representing the colour.
         * @returns A hexadecimal representation of this colour.
         */
        toHex() {
            return (
                "#" +
                RgbColour.componentToHex(this.r) +
                RgbColour.componentToHex(this.g) +
                RgbColour.componentToHex(this.b)
            );
        }

        /**
         * Updates the properties of this instance to represent the same colour as the
         * provided string in the hexadecimal format #rrggbb.
         * @param hex A hexadecimal string in the format '#rrggbb'.
         * @returns This instance after updating it.
         */
        loadFromHex(hex) {
            this.r = parseInt(hex.slice(1, 3), 16) / 255;
            this.g = parseInt(hex.slice(3, 5), 16) / 255;
            this.b = parseInt(hex.slice(5, 7), 16) / 255;
            return this;
        }

        /**
         * Updates the properties of this instance to represent the same colour as the
         * provided HsvColour but in the sRGB colour space.
         * @param hsv An HSV representation of a colour to copy.
         * @returns This instance after updating it.
         */
        loadFromHsv(hsv) {
            const hue = (hsv.h - Math.floor(hsv.h)) * 6;
            this.r =
                hsv.v *
                (1 - hsv.s * Math.max(0, Math.min(1, 2 - Math.abs(hue - 3))));
            this.g =
                hsv.v *
                (1 - hsv.s * Math.max(0, Math.min(1, Math.abs(hue - 2) - 1)));
            this.b =
                hsv.v *
                (1 - hsv.s * Math.max(0, Math.min(1, Math.abs(hue - 4) - 1)));
            return this;
        }
    }

    /**
     * A structure with three properties h, s, and v, representing the hue,
     * saturation, and brightness in a colour. All three properties range from 0
     * to 1.
     */
    class HsvColour {
        /**
         * The HsvColour constructor.
         * @param h The initial hue of the colour. Defaults to 0.
         * @param s The initial amount of saturation. Defaults to 0.
         * @param v The initial amount of brightness. Defaults to 0.
         */
        constructor(h = 0, s = 0, v = 0) {
            this.h = h;
            this.s = s;
            this.v = v;
        }

        /**
         * Updates the properties of this instance to represent the same colour as the
         * provided RgbColour but in the HSV colour space.
         * @param rgb An RGB representation of a colour to copy.
         * @returns This instance after updating it.
         */
        loadFromRgb(rgb) {
            const max = Math.max(Math.max(rgb.r, rgb.g), rgb.b);
            const min = Math.min(Math.min(rgb.r, rgb.g), rgb.b);
            this.v = max;
            if (min === max) {
                this.h = 0;
                this.s = 0;
                return this;
            }

            const delta = max - min;
            this.s = delta / max;

            let hue;
            if (rgb.r === max) {
                hue = (rgb.g - rgb.b) / delta;
            } else if (rgb.g === max) {
                hue = 2 + (rgb.b - rgb.r) / delta;
            } else {
                hue = 4 + (rgb.r - rgb.g) / delta;
            }
            hue /= 6;
            this.h = hue - Math.floor(hue);
            return this;
        }

        /**
         * Updates the properties of this instance to copy the provided HsvColour.
         * @param other An HSV representation of a colour to copy.
         * @returns This instance after updating it.
         */
        copy(other) {
            this.h = other.h;
            this.s = other.s;
            this.v = other.v;
            return this;
        }
    }

    /**
     * Class for a colour input field that displays HSV slider widgets when clicked.
     */
    class FieldColourHsvSliders extends FieldColour {
        /* eslint-disable @typescript-eslint/naming-convention */
        /** The maximum value of the hue slider range. */
        static HUE_SLIDER_MAX = 360;

        /** The maximum value of the saturation slider range. */
        static SATURATION_SLIDER_MAX = 100;

        /** The maximum value of the brightness slider range. */
        static BRIGHTNESS_SLIDER_MAX = 100;

        /**
         * The gradient control point positions should align with the center of the
         * slider thumb when the corresponding colour is selected. When the slider
         * is at the minimum or maximum value, the distance of center of the thumb
         * from the edge of the track will be the thumb's radius, so that's how far
         * the minimum and maximum control points should be.
         */
        static THUMB_RADIUS = 12;
        /* eslint-enable @typescript-eslint/naming-convention */

        /** Helper colour structures to allow manipulation in the HSV colour space. */
        static helperHsv = new HsvColour();

        /** Helper colour structures to support conversion to the RGB colour space. */
        static helperRgb = new RgbColour();

        /** Array holding info needed to unbind events. Used for disposing. */
        hsvBoundEvents = [];

        /** HTML span element to display the current hue. */
        hueReadout = null;

        /** HTML range input element for editing hue. */
        hueSlider = null;

        /** HTML span element to display the current saturation. */
        saturationReadout = null;

        /** HTML range input element for editing saturation. */
        saturationSlider = null;

        /** HTML span element to display the current brightness. */
        brightnessReadout = null;

        /** HTML range input element for editing brightness. */
        brightnessSlider = null;

        /** HTML div element containing all the labels and sliders. */
        dropdownContainer = null;

        /* eslint-disable @typescript-eslint/naming-convention */
        /**
         * Create and show the colour field's editor.
         * @override
         */
        showEditor_() {
            /* eslint-enable @typescript-eslint/naming-convention */
            this.createDropdownSliders();
            if (!this.dropdownContainer || !this.hueSlider) {
                throw new Error("Failed to initialize the HSV sliders.");
            }
            Blockly.DropDownDiv.getContentDiv().appendChild(
                this.dropdownContainer
            );

            Blockly.DropDownDiv.showPositionedByField(
                this,
                this.dropdownDisposeSliders.bind(this)
            );

            // Focus so we can start receiving keyboard events.
            this.hueSlider.focus({ preventScroll: true });
        }

        /**
         * Creates a row with a slider label and a readout to display the slider
         * value, appends it to the provided container, and returns the readout.
         * @param name The display name of the slider.
         * @param container Where the row will be inserted.
         * @returns The readout, so that it can be updated.
         */
        static createLabelInContainer(name, container) {
            const label = document.createElement("div");
            const labelText = document.createElement("span");
            const readout = document.createElement("span");
            label.classList.add("fieldColourSliderLabel");
            labelText.textContent = name;
            label.appendChild(labelText);
            label.appendChild(readout);
            container.appendChild(label);
            return readout;
        }

        /**
         * Creates a slider, appends it to the provided container, and returns it.
         * @param max The maximum value of the slider.
         * @param step The minimum step size of the slider.
         * @param container Where the row slider be inserted.
         * @returns The slider.
         */
        static createSliderInContainer(max, step, container) {
            const slider = document.createElement("input");
            slider.classList.add("fieldColourSlider");
            slider.type = "range";
            slider.min = String(0);
            slider.max = String(max);
            slider.step = String(step);
            container.appendChild(slider);
            return slider;
        }

        /** Creates the colour picker slider editor and adds event listeners. */
        createDropdownSliders() {
            const container = document.createElement("div");
            container.classList.add("fieldColourSliderContainer");

            this.hueReadout = FieldColourHsvSliders.createLabelInContainer(
                "Hue",
                container
            );
            this.hueSlider = FieldColourHsvSliders.createSliderInContainer(
                FieldColourHsvSliders.HUE_SLIDER_MAX,
                2,
                container
            );
            this.saturationReadout =
                FieldColourHsvSliders.createLabelInContainer(
                    "Saturation",
                    container
                );
            this.saturationSlider =
                FieldColourHsvSliders.createSliderInContainer(
                    FieldColourHsvSliders.SATURATION_SLIDER_MAX,
                    1,
                    container
                );
            this.brightnessReadout =
                FieldColourHsvSliders.createLabelInContainer(
                    "Brightness",
                    container
                );
            this.brightnessSlider =
                FieldColourHsvSliders.createSliderInContainer(
                    FieldColourHsvSliders.BRIGHTNESS_SLIDER_MAX,
                    1,
                    container
                );

            this.hsvBoundEvents.push(
                Blockly.browserEvents.conditionalBind(
                    this.hueSlider,
                    "input",
                    this,
                    this.onSliderChange
                )
            );
            this.hsvBoundEvents.push(
                Blockly.browserEvents.conditionalBind(
                    this.saturationSlider,
                    "input",
                    this,
                    this.onSliderChange
                )
            );
            this.hsvBoundEvents.push(
                Blockly.browserEvents.conditionalBind(
                    this.brightnessSlider,
                    "input",
                    this,
                    this.onSliderChange
                )
            );

            if (window.EyeDropper) {
                // If the browser supports the eyedropper API, create a button for it.
                const button = document.createElement("button");
                button.classList.add("fieldColourEyedropper");
                container.appendChild(document.createElement("hr"));
                container.appendChild(button);
                this.hsvBoundEvents.push(
                    Blockly.browserEvents.conditionalBind(
                        button,
                        "click",
                        this,
                        this.onEyedropperEvent
                    )
                );
            }

            this.dropdownContainer = container;

            this.updateSliderValues();
        }

        /** Disposes of events and DOM-references belonging to the colour editor. */
        dropdownDisposeSliders() {
            for (const event of this.hsvBoundEvents) {
                Blockly.browserEvents.unbind(event);
            }
            this.hsvBoundEvents.length = 0;
            this.hueReadout = null;
            this.hueSlider = null;
            this.saturationReadout = null;
            this.saturationSlider = null;
            this.brightnessReadout = null;
            this.brightnessSlider = null;
            this.dropdownContainer = null;
        }

        /**
         * A helper function that converts a colour, specified by the provided hue,
         * saturation, and brightness parameters, into a hexadecimal string in the
         * format "#rrggbb".
         * @param hue The hue of the colour.
         * @param saturation The saturation of the colour.
         * @param brightness The brightness of the colour.
         * @returns A hexadecimal representation of the colour in the format "#rrggbb"
         */
        static hsvToHex(hue, saturation, brightness) {
            FieldColourHsvSliders.helperHsv.h = hue;
            FieldColourHsvSliders.helperHsv.s = saturation;
            FieldColourHsvSliders.helperHsv.v = brightness;
            return FieldColourHsvSliders.helperRgb
                .loadFromHsv(FieldColourHsvSliders.helperHsv)
                .toHex();
        }

        /**
         * Updates the value of this field based on the editor sliders.
         * @param event Unused.
         */
        onSliderChange(event) {
            if (
                !this.hueSlider ||
                !this.saturationSlider ||
                !this.brightnessSlider
            ) {
                throw new Error("The HSV sliders are missing.");
            }
            const hue =
                parseFloat(this.hueSlider.value) /
                FieldColourHsvSliders.HUE_SLIDER_MAX;
            const saturation =
                parseFloat(this.saturationSlider.value) /
                FieldColourHsvSliders.SATURATION_SLIDER_MAX;
            const brightness =
                parseFloat(this.brightnessSlider.value) /
                FieldColourHsvSliders.BRIGHTNESS_SLIDER_MAX;
            this.setValue(
                FieldColourHsvSliders.hsvToHex(hue, saturation, brightness)
            );
            this.renderSliders();
        }

        /**
         * Updates the value of this field and editor sliders using an eyedropper.
         * @param event Unused.
         */
        onEyedropperEvent(event) {
            if (window.EyeDropper) {
                const eyeDropper = new window.EyeDropper();
                eyeDropper.open().then((result) => {
                    this.setValue(result.sRGBHex);
                    this.updateSliderValues();
                });
            }
        }

        /**
         * Updates the gradient backgrounds of the slider tracks and readouts based
         * on the slider values.
         */
        renderSliders() {
            if (
                !this.hueSlider ||
                !this.hueReadout ||
                !this.saturationSlider ||
                !this.saturationReadout ||
                !this.brightnessSlider ||
                !this.brightnessReadout
            ) {
                throw new Error("The HSV sliders are missing.");
            }
            this.hueReadout.textContent = this.hueSlider.value;
            this.saturationReadout.textContent = this.saturationSlider.value;
            this.brightnessReadout.textContent = this.brightnessSlider.value;

            const h =
                parseFloat(this.hueSlider.value) /
                FieldColourHsvSliders.HUE_SLIDER_MAX;
            const s =
                parseFloat(this.saturationSlider.value) /
                FieldColourHsvSliders.SATURATION_SLIDER_MAX;
            const v =
                parseFloat(this.brightnessSlider.value) /
                FieldColourHsvSliders.BRIGHTNESS_SLIDER_MAX;

            // The hue slider needs intermediate gradient control points to include all
            // colours of the rainbow.
            let hueGradient = "linear-gradient(to right, ";
            hueGradient +=
                FieldColourHsvSliders.hsvToHex(0 / 6, s, v) +
                ` ${FieldColourHsvSliders.THUMB_RADIUS}px, `;
            hueGradient += FieldColourHsvSliders.hsvToHex(1 / 6, s, v) + ", ";
            hueGradient += FieldColourHsvSliders.hsvToHex(2 / 6, s, v) + ", ";
            hueGradient += FieldColourHsvSliders.hsvToHex(3 / 6, s, v) + ", ";
            hueGradient += FieldColourHsvSliders.hsvToHex(4 / 6, s, v) + ", ";
            hueGradient += FieldColourHsvSliders.hsvToHex(5 / 6, s, v) + ", ";
            hueGradient +=
                FieldColourHsvSliders.hsvToHex(6 / 6, s, v) +
                ` calc(100% - ${FieldColourHsvSliders.THUMB_RADIUS}px))`;
            this.hueSlider.style.setProperty(
                "--slider-track-background",
                hueGradient
            );

            // The saturation slider only needs gradient control points at each end.
            let saturationGradient = "linear-gradient(to right, ";
            saturationGradient +=
                FieldColourHsvSliders.hsvToHex(h, 0, v) +
                ` ${FieldColourHsvSliders.THUMB_RADIUS}px, `;
            saturationGradient +=
                FieldColourHsvSliders.hsvToHex(h, 1, v) +
                ` calc(100% - ${FieldColourHsvSliders.THUMB_RADIUS}px))`;
            this.saturationSlider.style.setProperty(
                "--slider-track-background",
                saturationGradient
            );

            // The brightness slider only needs gradient control points at each end.
            let brightnessGradient = "linear-gradient(to right, ";
            brightnessGradient +=
                FieldColourHsvSliders.hsvToHex(h, s, 0) +
                ` ${FieldColourHsvSliders.THUMB_RADIUS}px, `;
            brightnessGradient +=
                FieldColourHsvSliders.hsvToHex(h, s, 1) +
                ` calc(100% - ${FieldColourHsvSliders.THUMB_RADIUS}px))`;
            this.brightnessSlider.style.setProperty(
                "--slider-track-background",
                brightnessGradient
            );
        }

        /** Updates slider values based on the current value of the field. */
        updateSliderValues() {
            if (
                !this.hueSlider ||
                !this.saturationSlider ||
                !this.brightnessSlider
            ) {
                return;
            }

            const hsv = FieldColourHsvSliders.helperHsv.loadFromRgb(
                FieldColourHsvSliders.helperRgb.loadFromHex(this.getValue() ?? "")
            );

            this.hueSlider.value = String(
                hsv.h * FieldColourHsvSliders.HUE_SLIDER_MAX
            );
            this.saturationSlider.value = String(
                hsv.s * FieldColourHsvSliders.SATURATION_SLIDER_MAX
            );
            this.brightnessSlider.value = String(
                hsv.v * FieldColourHsvSliders.BRIGHTNESS_SLIDER_MAX
            );

            this.renderSliders();
        }
    }

    Blockly.fieldRegistry.register(
        "field_colour_hsv_sliders",
        FieldColourHsvSliders
    );

    // CSS for colour slider fields.
    Blockly.Css.register(`
      .fieldColourSliderContainer {
        padding: 4px;
      }
      .fieldColourSliderContainer hr {
        border: none;
        border-top: 1px solid #bbb;
      }
      .fieldColourSliderLabel {
        display: flex;
        justify-content: space-between;
      }
      .fieldColourEyedropper {
        appearance: none;
        position: relative;
        border: none;
        border-radius: 4px;
        background: transparent;
        font: inherit;
        color: inherit;
        cursor: pointer;
        width: 100%;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .fieldColourEyedropper:hover {
        background: rgba(0,0,0,0.1)
      }
      .fieldColourEyedropper input {
        opacity: 0;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      .fieldColourEyedropper::before {
        content: "Eyedropper";
      }
      .fieldColourEyedropper::after {
        content: "";
        margin-left: 8px;
        width: 24px;
        height: 24px;
        background: currentColor;
        pointer-events: none;
        -webkit-mask-image: var(--customize-dial-symbol);
        -webkit-mask-repeat: no-repeat;
        -webkit-mask-position: center;
        mask-image: var(--customize-dial-symbol);
        mask-repeat: no-repeat;
        mask-position: center;
        --customize-dial-symbol: url('data:image/svg+xml,\
          <svg xmlns="http://www.w3.org/2000/svg" \
              width="24px" height="24px" \
              viewBox="0 0 24 24"> \
            <path stroke="black" strokewidth="1.414" fill="none" \
                  d="m 13 8 L 6 15 Q 3 18 2 21 Q 0 23 .5 23.5 Q 1 24 3 22 \
                      Q 6 21 9 18 L 16 11"/> \
            <path fill="black" \
                  d="m 12 7 Q 11 6 12 5 Q 13 4 14 5 Q 15 6 16 5 Q 20 -1 22.5 1.5 \
                      Q 25 4 19 8 Q 18 9 19 10 Q 20 11 19 12 Q 18 13 17 12"/> \
          </svg>');
      }
      .fieldColourSlider {
        -webkit-appearance: none;
        width: 150px;
        height: 24px;
        margin: 4px 8px 24px 8px;
        padding: 0;
      }
      .fieldColourSlider:last-child {
        margin-bottom: 4px;
      }
      .fieldColourSlider:focus {
        outline: none;
      }
      /* Webkit */
      .fieldColourSlider::-webkit-slider-runnable-track {
        background: var(--slider-track-background);
        border-radius: 8px;
        height: 16px;
      }
      .fieldColourSlider::-webkit-slider-thumb {
        -webkit-appearance: none;
        background: #fff;
        border-radius: 50%;
        box-shadow: 0 0 0 4px rgba(0,0,0,.15);
        cursor: pointer;
        width: ${FieldColourHsvSliders.THUMB_RADIUS * 2}px;
        height: ${FieldColourHsvSliders.THUMB_RADIUS * 2}px;
        margin-top: -4px;
      }
      /* Firefox */
      .fieldColourSlider::-moz-range-track {
        background: var(--slider-track-background);
        border-radius: 8px;
        height: 16px;
      }
      .fieldColourSlider::-moz-range-thumb {
        background: #fff;
        border: none;
        border-radius: 50%;
        box-shadow: 0 0 0 4px rgba(0,0,0,.15);
        cursor: pointer;
        width: ${FieldColourHsvSliders.THUMB_RADIUS * 2}px;
        height: ${FieldColourHsvSliders.THUMB_RADIUS * 2}px;
      }
      .fieldColourSlider::-moz-focus-outer {
        /* override the focus border style */
        border: 0;
      }
      /* IE */
      .fieldColourSlider::-ms-track {
        background: var(--slider-track-background);
        border-radius: 12px;
        width: 100%;
        height: 24px;
        /* remove default tick marks */
        color: transparent;
      }
      .fieldColourSlider::-ms-fill-lower  {
        background: transparent;
      }
      .fieldColourSlider::-ms-fill-upper  {
        background: transparent;
      }
      .fieldColourSlider::-ms-thumb {
        background: #fff;
        border: none;
        border-radius: 50%;
        box-shadow: 0 0 0 4px rgba(0,0,0,.15);
        cursor: pointer;
        width: ${FieldColourHsvSliders.THUMB_RADIUS * 2}px;
        height: ${FieldColourHsvSliders.THUMB_RADIUS * 2}px;
      }
      `);

    //Various Addon Classes we need
    window.ContinuousCategory = ContinuousCategory;
    window.ContinuousFlyout = ContinuousFlyout;
    window.ContinuousFlyoutMetrics = ContinuousFlyoutMetrics;
    window.ContinuousMetrics = ContinuousMetrics;
    window.ContinuousToolbox = ContinuousToolbox;
    window.DisableTopBlocks = DisableTopBlocks;

    onAllAddonsLoaded();
});</script>

    <!--helper functions-->
    <script>const addBlocklyBlock = (blockName, type, BlockJson, inline) => {
    inline = inline || true;
    switch (type) {
        case "hat":
            BlockJson.nextStatement = null;
            break;

        case "reporter":
            BlockJson.output = BlockJson.output || "Number";
            break;

        case "boolean":
            BlockJson.output = "Boolean";
            break;

        case "command":
            BlockJson.nextStatement = "Action";
            BlockJson.previousStatement = "Action";
            break;

        default:
            BlockJson.nextStatement = null;
            BlockJson.previousStatement = null;
            break;
    }
    Blockly.Blocks[blockName] = {
        init: function () {
            this.setInputsInline(inline);
            this.jsonInit(BlockJson);
        },
    };
};

window.variableTypes = [];

const addVariableType = (variableType, style, check, isBool, shadowDat) => {
    var blockType = isBool ? "boolean" : "reporter";
    style = style || "variable_blocks";

    addBlocklyBlock("variables_get_" + variableType, blockType, {
        type: "variables_get",
        message0: "%1",
        args0: [
            {
                type: "field_variable",
                name: "VAR",
                variable: "%{BKY_VARIABLES_DEFAULT_NAME}",
                variableTypes: [variableType],    // Specifies what types to put in the dropdown
                defaultType: variableType  //The default type of the variable
            }
        ],
        style: style,
        output: (typeof check == "object" && check != null) ? check[0] : check
    });

    shadowDat = shadowDat || { madeUp: true };

    if (!shadowDat.noSet) {
        addBlocklyBlock("variables_set_" + variableType, "command", {
            type: "variables_set",
            message0: "set %1 to %2",
            args0: [
                {
                    type: "field_variable",
                    name: "VAR",
                    variable: "%{BKY_VARIABLES_DEFAULT_NAME}",
                    variableTypes: [variableType],    // Specifies what types to put in the dropdown
                    defaultType: variableType  //The default type of the variable
                },
                {
                    type: "input_value",    // This expects an input of any type
                    name: "VALUE",
                    check: check
                }
            ],
            style: style
        });
    }
    window.variableTypes.push({ kind: "label", text: variableType, })
    if (!shadowDat.noSet) {
        if (!shadowDat.madeUp) {
            window.variableTypes.push({ kind: "block", type: "variables_set_" + variableType, inputs: shadowDat })
        }
        else {
            window.variableTypes.push({ kind: "block", type: "variables_set_" + variableType, })
        }
    }
    window.variableTypes.push({ kind: "block", type: "variables_get_" + variableType, })
}

function hexToRgb(hex) {
    if (typeof hex === "string") {
        const splitHex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return {
            r: parseInt(splitHex[1], 16),
            g: parseInt(splitHex[2], 16),
            b: parseInt(splitHex[3], 16),
        };
    }
    return {
        r: Math.floor(hex / 65536),
        g: Math.floor(hex / 256) % 256,
        b: hex % 256,
    };
}

function createMenu(contents, named) {
    return {
        "type": "field_dropdown",
        "name": named,
        "options": contents
    }
}

function createModal(HTML) {
    const modal = {
        background: document.createElement("div")
    };

    modal.background.style.backgroundColor = "#00000066";
    modal.background.style.width = "100%";
    modal.background.style.height = "100%";
    modal.background.style.position = "absolute";
    modal.background.style.left = "0px";
    modal.background.style.top = "0px";

    modal.background.innerHTML = HTML;

    modal.background.style.zIndex = "500";

    document.body.appendChild(modal.background);

    modal.close = () => {
        document.body.removeChild(modal.background);
    }

    return modal;
}</script>
    <!--Blockly Theme-->
    <script>function penPlusBlocklyTheme() {

    const blockStyles = {
        hat_blocks: {
            colourPrimary: "#ffbf00",
            colourSecondary: "#e6ac00",
            colourTertiary: "#cc9900",
        },
        logic_blocks: {
            colourPrimary: "#ffab19",
            colourSecondary: "#ec9c13",
            colourTertiary: "#cf8b17",

        },
        looks_blocks: {
            colourPrimary: "#9966ff",
            colourSecondary: "#855cd6",
            colourTertiary: "#774dcb",
        },
        operator_blocks: {
            colourPrimary: "#59c059",
            colourSecondary: "#46b946",
            colourTertiary: "#389438",
        },
        vertex_blocks: {
            colourPrimary: "#4c97ff",
            colourSecondary: "#4488e6",
            colourTertiary: "#3d79cc",
        },
        variable_blocks: {
            colourPrimary: "#ff8c1a",
            colourSecondary: "#dd8126",
            colourTertiary: "#cc7015"
        },
        variable_vec2_block: {
            colourPrimary: "#5AB897",
            colourSecondary: "#47AA8C",
            colourTertiary: "#339178"
        },
        variable_vec3_block: {
            colourPrimary: "#5BB4B7",
            colourSecondary: "#47AAAF",
            colourTertiary: "#319098"
        },
        variable_vec4_block: {
            colourPrimary: "#59BC77",
            colourSecondary: "#47AB6A",
            colourTertiary: "#359258"
        },
        variable_int_block: {
            colourPrimary: "#ffde00",
            colourSecondary: "#e6c800",
            colourTertiary: "#ccb100",
        },
        variable_bool_block: {
            colourPrimary: "#c2d916",
            colourSecondary: "#adc213",
            colourTertiary: "#a0b312"
        },
        texture_blocks: {
            colourPrimary: "#b464e7",
            colourSecondary: "#a755cf",
            colourTertiary: "#9a48c4"
        },
        cubemap_blocks: {
            colourPrimary: "#8672ff",
            colourSecondary: "#7465d6",
            colourTertiary: "#6657cb"
        },
        matrix_blocks: {
            colourPrimary: "#737fff",
            colourSecondary: "#636ed6",
            colourTertiary: "#5560cb"
        }
    };

    return Blockly.Theme.defineTheme("themeName", {
        blockStyles: blockStyles,
        fontStyle: {
            'family': 'helvetica Neue, helvetica, serif',
            'weight': 500,
            'size': 12
        },
        componentStyles: {
            workspaceBackgroundColour: '#1e1e1e',
            toolboxBackgroundColour: 'blackBackground',
            toolboxForegroundColour: '#fff',
            flyoutBackgroundColour: '#252526',
            flyoutForegroundColour: '#ccc',
            flyoutOpacity: 1,
            scrollbarColour: '#797979',
            insertionMarkerColour: '#fff',
            insertionMarkerOpacity: 0.3,
            scrollbarOpacity: 0.4,
            cursorColour: '#d0d0d0',
            blackBackground: '#333',
        },
        startHats: true,
    });
}</script>
    <!--Adding Blocks to palletes-->
    <script>//Defines blocks. Should probably split this into multiple files lol.
function addImportantReporters() {
    //The colour reporter
    addBlocklyBlock("color_reporter", "reporter", {
        message0: " %1 ",
        args0: [
            {
                type: "field_colour_hsv_sliders",
                name: "COLOUR",
                colour: "#0000ff",
            },
        ],
        output: "vec4"
    });
    addBlocklyBlock("number_reporter", "reporter", {
        message0: " %1 ",
        args0: [
            {
                type: "field_number",
                name: "NUMBER",
                value: 0,
            },
        ],
    });

    addBlocklyBlock("int_reporter", "reporter", {
        message0: " %1 ",
        args0: [
            {
                type: "field_number",
                name: "NUMBER",
                value: 0,
                precision: 1
            },
        ],
    });

    addBlocklyBlock("vec2_reporter", "reporter", {
        message0: "x:%1 y:%2",
        style: "variable_vec2_block",
        output: "vec2",
        args0: [
            {
                type: "field_number",
                name: "NUMBER",
                value: 0,
            },
            {
                type: "field_number",
                name: "NUMBER2",
                value: 0,
            },
        ],
    });

    addBlocklyBlock("vec3_reporter", "reporter", {
        message0: "x:%1 y:%2 z:%3",
        style: "variable_vec3_block",
        output: "vec3",
        args0: [
            {
                type: "field_number",
                name: "NUMBER",
                value: 0,
            },
            {
                type: "field_number",
                name: "NUMBER2",
                value: 0,
            },
            {
                type: "field_number",
                name: "NUMBER3",
                value: 0,
            },
        ],
    });

    addBlocklyBlock("vec4_reporter", "reporter", {
        message0: "x:%1 y:%2 z:%3 w:%4",
        style: "variable_vec4_block",
        output: "vec4",
        args0: [
            {
                type: "field_number",
                name: "NUMBER",
                value: 0,
            },
            {
                type: "field_number",
                name: "NUMBER2",
                value: 0,
            },
            {
                type: "field_number",
                name: "NUMBER2",
                value: 0,
            },
            {
                type: "field_number",
                name: "NUMBER2",
                value: 0,
            }
        ],
    });
}

function addVariableTypes() {
    window.variableTypes.push({
        "kind": "button",
        "text": "Create Variable",
        "callbackKey": "createVariable"
    })
    addVariableType("float", null, null, false, {
        VALUE: {
            shadow: {
                type: "number_reporter",
            },
        },
    });
    addVariableType("int", "variable_int_block", null, false, {
        VALUE: {
            shadow: {
                type: "int_reporter",
            },
        },
    });
    addVariableType("vec2", "variable_vec2_block", ["vec2", "VectorCompliant"], false, {
        VALUE: {
            shadow: {
                type: "vec2_reporter",
            },
        },
    });
    addVariableType("vec3", "variable_vec3_block", ["vec3", "VectorCompliant"], false, {
        VALUE: {
            shadow: {
                type: "vec3_reporter",
            },
        },
    });

    addVariableType("vec4", "variable_vec4_block", ["vec4", "VectorCompliant"], false, {
        VALUE: {
            shadow: {
                type: "vec4_reporter",
            },
        },
    });

    addVariableType("bool", "variable_bool_block", "Boolean", true);

    addVariableType("texture", "texture_blocks", ["texture"], false, {
        noSet: true
    });

    addVariableType("cubemap", "cubemap_blocks", ["cubemap"], false, {
        noSet: true
    });

    addVariableType("matrix", "matrix_blocks", ["Matrix", "VectorCompliant"], false);
}

function addBlocks() {
    //Events
    addBlocklyBlock("as_vertex", "hat", {
        type: "vertice",
        message0: "for each vertex",
        style: "hat_blocks",
        tooltip:
            "The vertices execute this. (The points of a triangle or square!)",
    });

    addBlocklyBlock("as_frag", "hat", {
        type: "fragment",
        message0: "for each pixel",
        style: "hat_blocks",
        tooltip:
            "The pixels execute this. (The points of a triangle or square!)",
    });

    //Vertices
    addBlocklyBlock("vertex_gotoPos", "command", {
        type: "vertice",
        message0: "go to x:%1 y:%2",
        args0: [
            {
                type: "input_value",
                name: "X",
            },
            {
                type: "input_value",
                name: "Y",
            },
        ],
        style: "vertex_blocks",
        tooltip: "Set the vertice's screen position to this",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_setZ", "command", {
        type: "vertice",
        message0: "set depth to %1",
        args0: [
            {
                type: "input_value",
                name: "Z",
            },
        ],
        style: "vertex_blocks",
        tooltip: "Set the vertice's Depth or Z to this",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_setW", "command", {
        type: "vertice",
        message0: "set corner pinch to %1",
        args0: [
            {
                type: "input_value",
                name: "W",
            },
        ],
        style: "vertex_blocks",
        tooltip: "Set the vertice's corner pinch or W value to this",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_changeX", "command", {
        type: "vertice",
        message0: "change x by %1",
        args0: [
            {
                type: "input_value",
                name: "X",
            }
        ],
        style: "vertex_blocks",
        tooltip: "Change the vertice's x position by the desired value.",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_changeY", "command", {
        type: "vertice",
        message0: "change y by %1",
        args0: [
            {
                type: "input_value",
                name: "Y",
            }
        ],
        style: "vertex_blocks",
        tooltip: "Change the vertice's y position by the desired value.",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_changeZ", "command", {
        type: "vertice",
        message0: "change depth by %1",
        args0: [
            {
                type: "input_value",
                name: "Z",
            },
        ],
        style: "vertex_blocks",
        tooltip: "Change the vertice's Depth or Z by this",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_changeW", "command", {
        type: "vertice",
        message0: "change corner pinch by %1",
        args0: [
            {
                type: "input_value",
                name: "W",
            },
        ],
        style: "vertex_blocks",
        tooltip: "Change the vertice's corner pinch or W value by this",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_getX", "reporter", {
        type: "vertice",
        message0: "vertex X",
        style: "vertex_blocks",
        tooltip: "Get the vertice's X position",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_getY", "reporter", {
        type: "vertice",
        message0: "vertex Y",
        style: "vertex_blocks",
        tooltip: "Get the vertice's Y position",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_getZ", "reporter", {
        type: "vertice",
        message0: "vertex depth",
        style: "vertex_blocks",
        tooltip: "Get the vertice's depth or Z position",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("vertex_getW", "reporter", {
        type: "vertice",
        message0: "vertex corner pinch",
        style: "vertex_blocks",
        tooltip: "Get the vertice's corner pinch or W position",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    //Looks
    addBlocklyBlock("pixel_vertColor", "command", {
        type: "vertice",
        message0: "set the vertice's colour to %1",
        args0: [
            {
                type: "input_value",
                name: "COLOR",
                check: "vec4"
            },
        ],
        style: "looks_blocks",
        tooltip: "Set the pixel's colour to this",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("pixel_color", "command", {
        type: "fragment",
        message0: "set the pixel's colour to %1",
        args0: [
            {
                type: "input_value",
                name: "COLOR",
                check: "vec4"
            },
        ],
        style: "looks_blocks",
        tooltip: "Set the pixel's colour to this",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("pixel_X", "reporter", {
        type: "fragment",
        message0: "pixel X",
        style: "looks_blocks",
        tooltip: "Pixel's X position",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("pixel_Y", "reporter", {
        type: "fragment",
        message0: "pixel Y",
        style: "looks_blocks",
        tooltip: "Pixel's Y position",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("pixel_pixcolour", "reporter", {
        type: "fragment",
        message0: "pixel colour",
        style: "looks_blocks",
        tooltip: "The pixel's current colour",
        output: "vec4",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("pixel_vertcolour", "reporter", {
        type: "",
        message0: "vertice colour",
        style: "looks_blocks",
        tooltip: "The closest vertice's colour",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
        output: "vec4"
    });

    //Controls
    addBlocklyBlock("control_if", "command", {
        message0: "if %1 then %2 %3",
        args0: [
            {
                type: "input_value",
                check: "Boolean",
                name: "condition",
            },
            {
                type: "input_dummy",
            },
            {
                type: "input_statement",
                name: "true",
            },
        ],
        style: "logic_blocks",
        tooltip: "If the input is true execute the inline code.",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("control_ifelse", "command", {
        message0: "if %1 then %2 %3 else %4 %5",
        args0: [
            {
                "type": "input_value",
                "name": "condition",
                "check": "Boolean"
            },
            {
                "type": "input_dummy"
            },
            {
                "type": "input_statement",
                "name": "true"
            },
            {
                "type": "input_dummy"
            },
            {
                "type": "input_statement",
                "name": "false"
            }
        ],
        style: "logic_blocks",
        tooltip: "If the input is true execute the inline code.",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("control_repeat", "command", {
        message0: "repeat %1 %2",
        args0: [
            {
                type: "input_value",
                name: "times",
            },
            {
                type: "input_statement",
                name: "code",
            },
        ],
        style: "logic_blocks",
        tooltip: "Repeats the specified amount of times.",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    //Operators
    addBlocklyBlock("operator_add", "reporter", {
        message0: "%1+%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "Add two numbers together",
        output: ["VectorCompliant"],
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_sub", "reporter", {
        message0: "%1-%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "Subtracts A from B",
        output: ["VectorCompliant"],
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_mul", "reporter", {
        message0: "%1*%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "Multiplies A and B together",
        output: ["VectorCompliant"],
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_div", "reporter", {
        message0: "%1/%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "Divides A by B",
        output: ["VectorCompliant"],
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_pow", "reporter", {
        message0: "%1^%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "Divides A by B",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_mod", "reporter", {
        message0: "%1 mod %2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "Gets the remainder of the division of A and B",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    //Conditionals
    addBlocklyBlock("operator_equalTo", "boolean", {
        message0: "%1=%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "is A equal to B",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });
    addBlocklyBlock("operator_notequalTo", "boolean", {
        message0: "%1!=%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "is A not equal to B",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });
    addBlocklyBlock("operator_lessThan", "boolean", {
        message0: "%1<%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "is A less than to B",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });
    addBlocklyBlock("operator_lessThanEqual", "boolean", {
        message0: "%1<=%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "is A less than or equal to to B",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_moreThan", "boolean", {
        message0: "%1>%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "is A more than to B",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });
    addBlocklyBlock("operator_moreThanEqual", "boolean", {
        message0: "%1>=%2",
        args0: [
            {
                type: "input_value",
                name: "A",
            },
            {
                type: "input_value",
                name: "B",
            },
        ],
        style: "operator_blocks",
        tooltip: "is A more than or equal to to B",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    //True and False
    addBlocklyBlock("operator_true", "boolean", {
        message0: "true",
        style: "operator_blocks",
        tooltip: "Always true",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });
    addBlocklyBlock("operator_false", "boolean", {
        message0: "false",
        style: "operator_blocks",
        tooltip: "Always false",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_and", "boolean", {
        message0: "%1 and %2",
        args0: [
            {
                type: "input_value",
                check: "Boolean",
                name: "A",
            },
            {
                type: "input_value",
                check: "Boolean",
                name: "B",
            }
        ],
        style: "operator_blocks",
        tooltip: "return true if A and B are true",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_or", "boolean", {
        message0: "%1 or %2",
        args0: [
            {
                type: "input_value",
                check: "Boolean",
                name: "A",
            },
            {
                type: "input_value",
                check: "Boolean",
                name: "B",
            }
        ],
        style: "operator_blocks",
        tooltip: "return true if A or B is true",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });


    addBlocklyBlock("operator_not", "boolean", {
        message0: "not%1",
        args0: [
            {
                type: "input_value",
                check: "Boolean",
                name: "A",
            }
        ],
        style: "operator_blocks",
        tooltip: "opposite of the input!",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    });

    addBlocklyBlock("operator_arith", "reporter", {
        message0: "%1 of %2",
        args0: [
            createMenu([
                ["abs", "abs"],
                ["floor", "floor"],
                ["ceiling", "ceil"],
                ["sqrt", "sqrt"],
                ["sin", "sin"],
                ["cos", "cos"],
                ["tan", "tan"],
                ["ln", "log"],
                ["log", "log10"],
                ["e^", "exp"],
                ["10^", "tenpow"],
            ], "arithmatic"),
            {
                type: "input_value",
                name: "A",
            },
        ],
        style: "operator_blocks",
        tooltip: "Uses the value of the arithmatic",
        helpUrl: "https://doors-game.fandom.com/wiki/DOORS_Wiki",
    })
}</script>
    <script>{
    const glsl_Button = document.getElementById("ButtonGLSL")
    const blockly_Button = document.getElementById("ButtonBlockly")

    glsl_Button.onclick = () => {
        document.body.style.setProperty("--CodeVis", "visible");
        document.body.style.setProperty("--BlocklyVis", "hidden");

        glsl_Button.className = "buttonSelected";
        blockly_Button.className = "buttonUnselected";
    }

    blockly_Button.onclick = () => {
        document.body.style.setProperty("--CodeVis", "hidden");
        document.body.style.setProperty("--BlocklyVis", "visible");

        glsl_Button.className = "buttonUnselected";
        blockly_Button.className = "buttonSelected";
    }
}</script>

    <!--Shader Preview and errors-->
    <script>const gl = document.getElementById("shaderpreview").getContext("webgl");

window.ShaderObject = {
    program: undefined,
    vert: undefined,
    frag: undefined,
};

function shaderLog(reason) {
    const logThing = document.createElement("div");
    logThing.innerHTML = Date.now() + "::" + reason;
    logThing.className = "logText";

    console.log(reason);

    document.getElementById("shaderLog").appendChild(logThing);
}

function replacementShader(reason) {
    shaderLog(reason);
}

function genProgram() {
    //If we already have a shader delete it to hopefully save memory.
    if (window.ShaderObject.program) {
        gl.deleteProgram(window.ShaderObject.program);
        gl.deleteShader(window.ShaderObject.vert);
        gl.deleteShader(window.ShaderObject.frag);
    }

    //Split the shader code into fragment and vertice shaders
    if (window.Generated_GLSL.indexOf("//Fragment Shader") <= window.Generated_GLSL.indexOf("//Vertex Shader")) {
        window.Generated_Frag = window.Generated_GLSL.substring(0, window.Generated_GLSL.indexOf("//Vertex Shader"));

        window.Generated_Vert = window.Generated_GLSL.substring(0, window.Generated_GLSL.indexOf("//Fragment Shader")) +
            window.Generated_GLSL.substring(window.Generated_GLSL.indexOf("//Vertex Shader"), window.Generated_GLSL.length);
    }
    else {
        window.Generated_Vert = window.Generated_GLSL.substring(0, window.Generated_GLSL.indexOf("//Fragment Shader"));

        window.Generated_Frag = window.Generated_GLSL.substring(0, window.Generated_GLSL.indexOf("//Vertex Shader")) +
            window.Generated_GLSL.substring(window.Generated_GLSL.indexOf("//Fragment Shader"), window.Generated_GLSL.length);
    }

    //Replace their functions with main functions
    window.Generated_Vert = window.Generated_Vert.replace(" vertex", " main");
    window.Generated_Frag = window.Generated_Frag.replace(" fragment", " main");

    //Remove attributes from fragment
    window.Generated_Frag = window.Generated_Frag.replace(/attribute (.*?);/g, "");

    //Get the variables for later use from the global window class
    let vert = window.Generated_Vert;
    let frag = window.Generated_Frag;

    //? compile vertex Shader
    const vertShader = gl.createShader(gl.VERTEX_SHADER);
    try {
        gl.shaderSource(vertShader, vert.trim());
        gl.compileShader(vertShader);
        if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
            throw gl.getShaderInfoLog(vertShader);
        }
    } catch (error) {
        replacementShader(error);
    }

    //? compile fragment Shader
    const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    try {
        gl.shaderSource(fragShader, frag.trim());
        gl.compileShader(fragShader);
        if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
            throw gl.getShaderInfoLog(fragShader);
        }
    } catch (error) {
        replacementShader(error);
    }

    //? compile program
    const program = gl.createProgram();
    try {
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw gl.getProgramInfoLog(program);
        }

        gl.validateProgram(program);
        if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
            throw gl.getProgramInfoLog(program);
        }
    } catch (error) {
        replacementShader(error);
    }

    window.ShaderObject = {
        program: program,
        vert: vertShader,
        frag: fragShader,
    };
}</script>

    <!--GLSL generator-->
    <script>let loopID = 0;
let functionsThatExist = {
    vert: false,
    frag: false,
}

window.Generated_GLSL = `//Base Variables
attribute highp vec4 a_position;
attribute highp vec4 a_color;
attribute highp vec2 a_texCoord;
 
varying highp vec4 v_color;
varying highp vec2 v_texCoord;

varying highp float v_depth;

//Pen+ Textures
uniform sampler2D u_texture;
uniform mediump vec2 u_res;
uniform sampler2D u_depthTexture;

//Base functions
highp float log10(highp float a) {
  return log(a)/log(10.0);
}

highp float eulernum(highp float a) {
    return 2.718 * a;
}

//Vertex Shader
void vertex() {
gl_Position = a_position;
}
//Fragment Shader
void fragment() {
gl_FragColor = v_color;
}
`;

function createGLSLGen() {
    window.GLSL_GEN = new Blockly.Generator('GLSL');
    const GLSL_GEN = window.GLSL_GEN;

    const Order = {
        ATOMIC: 0,
    }

    function nextBlockToCode(block, generator) {
        const nextBlock =
            block.nextConnection && block.nextConnection.targetBlock();
        let appended = ''
        if (nextBlock) {
            return '\n' + GLSL_GEN.blockToCode(nextBlock);
        }
        return ''
    }

    GLSL_GEN.forBlock['number_reporter'] = function (block, generator) {
        const numba = block.getFieldValue("NUMBER");
        return [`${numba}`, Order.ATOMIC];
    };

    GLSL_GEN.forBlock['operator_add'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} + ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    };

    GLSL_GEN.forBlock['operator_sub'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} - ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    };

    GLSL_GEN.forBlock['operator_mul'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} * ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    };

    GLSL_GEN.forBlock['operator_div'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} / ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    };

    GLSL_GEN.forBlock['operator_pow'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`pow(${A}, ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    };

    GLSL_GEN.forBlock['operator_equalTo'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} == ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_notequalTo'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} != ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_lessThan'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} < ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_lessThanEqual'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} <= ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_moreThan'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} > ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_moreThanEqual'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} >= ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_and'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} && ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_or'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`(${A} || ${B})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_not'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        return [`!(${A})` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_true'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`true` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_false'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`false` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['operator_mod'] = function (block, generator) {
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        const B = generator.valueToCode(block, 'B', Order.ATOMIC);
        return [`mod(float(${A}),float(${B}))` + nextBlockToCode(block, generator), Order.ATOMIC];
    };

    GLSL_GEN.forBlock['operator_arith'] = function (block, generator) {
        const arith = block.getFieldValue('arithmatic');
        const A = generator.valueToCode(block, 'A', Order.ATOMIC);
        return [`${arith}(float(${A}))` + nextBlockToCode(block, generator), Order.ATOMIC];
    };

    GLSL_GEN.forBlock['color_reporter'] = function (block, generator) {
        const colour = block.getFieldValue("COLOUR");
        let converted = hexToRgb(colour);
        converted.r /= 255;
        converted.g /= 255;
        converted.b /= 255;
        return [`vec4(${converted.r},${converted.g},${converted.b},1.0)`, Order.ATOMIC];
    };

    GLSL_GEN.forBlock['pixel_pixcolour'] = function (block, generator) {
        return [`gl_FragColor`, Order.ATOMIC];
    };

    GLSL_GEN.forBlock['pixel_vertcolour'] = function (block, generator) {
        return [`v_color`, Order.ATOMIC];
    };

    GLSL_GEN.forBlock['pixel_color'] = function (block, generator) {
        const colour = generator.valueToCode(block, 'COLOR', Order.ATOMIC);
        return `gl_FragColor = ${colour};` + nextBlockToCode(block, generator);
    };

    GLSL_GEN.forBlock['pixel_vertColor'] = function (block, generator) {
        const colour = generator.valueToCode(block, 'COLOR', Order.ATOMIC);
        return `v_color = ${colour};` + nextBlockToCode(block, generator);
    };

    GLSL_GEN.forBlock['pixel_X'] = function (block, generator) {
        return [`gl_FragCoord.x`, Order.ATOMIC];
    }

    GLSL_GEN.forBlock['pixel_Y'] = function (block, generator) {
        return [`gl_FragCoord.y`, Order.ATOMIC];
    }

    GLSL_GEN.forBlock['vertex_gotoPos'] = function (block, generator) {
        const X = generator.valueToCode(block, 'X', Order.ATOMIC);
        const Y = generator.valueToCode(block, 'Y', Order.ATOMIC);
        return `gl_Position.xy = vec2(float(${X}),float(${Y}));` + nextBlockToCode(block, generator);
    }

    GLSL_GEN.forBlock['vertex_setZ'] = function (block, generator) {
        const Z = generator.valueToCode(block, 'Z', Order.ATOMIC);
        return `gl_Position.z = float(${Z});` + nextBlockToCode(block, generator);
    }

    GLSL_GEN.forBlock['vertex_setW'] = function (block, generator) {
        const W = generator.valueToCode(block, 'W', Order.ATOMIC);
        return `gl_Position.w = float(${W});` + nextBlockToCode(block, generator);
    }

    GLSL_GEN.forBlock['vertex_changeX'] = function (block, generator) {
        const X = generator.valueToCode(block, 'X', Order.ATOMIC);
        return `gl_Position.x += float(${X});` + nextBlockToCode(block, generator);
    }

    GLSL_GEN.forBlock['vertex_changeY'] = function (block, generator) {
        const Y = generator.valueToCode(block, 'Y', Order.ATOMIC);
        return `gl_Position.y += float(${Y});` + nextBlockToCode(block, generator);
    }

    GLSL_GEN.forBlock['vertex_changeZ'] = function (block, generator) {
        const Z = generator.valueToCode(block, 'Z', Order.ATOMIC);
        return `gl_Position.z += float(${Z});` + nextBlockToCode(block, generator);
    }

    GLSL_GEN.forBlock['vertex_changeW'] = function (block, generator) {
        const W = generator.valueToCode(block, 'W', Order.ATOMIC);
        return `gl_Position.w += float(${W});` + nextBlockToCode(block, generator);
    }

    GLSL_GEN.forBlock['vertex_getX'] = function (block, generator) {
        return [`gl_Position.x` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['vertex_getY'] = function (block, generator) {
        return [`gl_Position.y` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['vertex_getZ'] = function (block, generator) {
        return [`gl_Position.z` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['vertex_getW'] = function (block, generator) {
        return [`gl_Position.w` + nextBlockToCode(block, generator), Order.ATOMIC];
    }

    GLSL_GEN.forBlock['control_if'] = function (block, generator) {
        const condition = generator.valueToCode(block, "condition", Order.ATOMIC);
        const trueExec = generator.statementToCode(block, "true");
        return `if (${condition}) {\n${trueExec}\n}`;
    }

    GLSL_GEN.forBlock['control_ifelse'] = function (block, generator) {
        const condition = generator.valueToCode(block, "condition", Order.ATOMIC);
        const trueExec = generator.statementToCode(block, "true");
        const falseExec = generator.statementToCode(block, "false");
        return `if (${condition}) {\n${trueExec}\n}\nelse{\n${falseExec}\n}`;
    }

    GLSL_GEN.forBlock['control_repeat'] = function (block, generator) {
        const times = generator.valueToCode(block, "times", Order.ATOMIC);
        const code = generator.statementToCode(block, "code");
        loopID += 1;
        return `for (int penPlusLoop_${loopID}=0;penPlusLoop_${loopID}<${times};penPlusLoop_${loopID}++) {\n${code}\n}`;
    }

    GLSL_GEN.forBlock['as_vertex'] = function (block, generator) {
        //const innerCode = generator.blockToCode(block.nextStatement);
        functionsThatExist.vert = true;
        return `//Vertex Shader\nvoid vertex() {\ngl_Position = a_position;${nextBlockToCode(block, generator)}\n}`;
    };

    GLSL_GEN.forBlock['as_frag'] = function (block, generator) {
        //const innerCode = generator.blockToCode(block.nextStatement);
        functionsThatExist.frag = true;
        return `//Fragment Shader\nvoid fragment() {${nextBlockToCode(block, generator)}\n}`;
    };
}

function updateGLSL(event) {
    if (window.workspace.isDragging()) return; // Don't update while changes are happening.
    if (!window.supportedEvents.has(event.type)) return;

    functionsThatExist = {
        vert: false,
        frag: false,
    }

    window.Generated_GLSL = `//Base Variables
attribute highp vec4 a_position;
attribute highp vec4 a_color;
attribute highp vec2 a_texCoord;
 
varying highp vec4 v_color;
varying highp vec2 v_texCoord;

varying highp float v_depth;

//Pen+ Textures
uniform sampler2D u_texture;
uniform mediump vec2 u_res;
uniform sampler2D u_depthTexture;

//Base functions
highp float log10(highp float a) {
  return log(a)/log(10.0);
}

highp float eulernum(highp float a) {
    return 2.718 * a;
}
`;

    window.Generated_GLSL += window.GLSL_GEN.workspaceToCode(window.workspace);

    window.Generated_Frag = "";
    window.Generated_Vert = "";

    loopID = 0;

    if (!(window.Generated_GLSL.includes("//Fragment Shader") && window.Generated_GLSL.includes("//Vertex Shader"))) {
        if ((!window.Generated_GLSL.includes("//Vertex Shader")) && window.Generated_GLSL.includes("//Fragment Shader")) {
            replacementShader("Missing Vertex Shader creating manual replacement");
            window.Generated_GLSL += `//Vertex Shader
void vertex() {
gl_Position = a_position;
}`;
        }
        else if ((!window.Generated_GLSL.includes("//Fragment Shader")) && window.Generated_GLSL.includes("//Vertex Shader")) {
            replacementShader("Missing Pixel/Fragment Shader creating manual replacement");
            window.Generated_GLSL += `//Fragment Shader
void fragment() {
gl_FragColor = v_color;
}`;
        }
        else {
            replacementShader("Missing both shaders using generic set");
            window.Generated_GLSL += `//Vertex Shader t
void vertex() {
gl_Position = a_position;
}`;
            window.Generated_GLSL += `\n//Fragment Shader
void fragment() {
gl_FragColor = v_color;
}`;
        }
    }

    document.getElementById("myBlocklyCodeOutput").value = window.Generated_GLSL;

    genProgram();
}</script>
    
    <script>function onAllAddonsLoaded() {
    createGLSLGen();
    addImportantReporters();
    addVariableTypes();
    addBlocks();

    const toolbox = {
      kind: "categoryToolbox",
      contents: [
        {
          kind: "category",
          name: "Events",
          colour: "#ffbf00",
          contents: [
            {
              kind: "block",
              type: "as_vertex",
            },
            {
              kind: "block",
              type: "as_frag",
            },
          ],
        },
        {
          kind: "category",
          name: "Vertex",
          colour: "#4c97ff",
          contents: [
            {
              kind: "block",
              type: "vertex_gotoPos",
              inputs: {
                X: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                Y: {
                  shadow: {
                    type: "number_reporter",
                  },
                }
              }
            },
            {
              kind: "block",
              type: "vertex_setZ",
              inputs: {
                Z: {
                  shadow: {
                    type: "number_reporter",
                  },
                }
              }
            },
            {
              kind: "block",
              type: "vertex_setW",
              inputs: {
                W: {
                  shadow: {
                    type: "number_reporter",
                  },
                }
              }
            },
            {
              kind: "label",
              text: ""
            },
            {
              kind: "block",
              type: "vertex_changeX",
              inputs: {
                X: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              }
            },
            {
              kind: "block",
              type: "vertex_changeY",
              inputs: {
                Y: {
                  shadow: {
                    type: "number_reporter",
                  },
                }
              }
            },
            {
              kind: "block",
              type: "vertex_changeZ",
              inputs: {
                Z: {
                  shadow: {
                    type: "number_reporter",
                  },
                }
              }
            },
            {
              kind: "block",
              type: "vertex_changeW",
              inputs: {
                W: {
                  shadow: {
                    type: "number_reporter",
                  },
                }
              }
            },
            {
              kind: "label",
              text: ""
            },
            {
              kind: "block",
              type: "vertex_getX",
            },
            {
              kind: "block",
              type: "vertex_getY",
            },
            {
              kind: "block",
              type: "vertex_getZ",
            },
            {
              kind: "block",
              type: "vertex_getW",
            },
          ],
        },
        {
          kind: "category",
          name: "Looks",
          colour: "#9966ff",
          contents: [
            {
              kind: "block",
              type: "pixel_color",
              inputs: {
                COLOR: {
                  shadow: {
                    type: "color_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "pixel_vertColor",
              inputs: {
                COLOR: {
                  shadow: {
                    type: "color_reporter",
                  },
                },
              },
            },
            {
              kind: "label",
              text: ""
            },
            {
              kind: "block",
              type: "pixel_X",
            },
            {
              kind: "block",
              type: "pixel_Y",
            },
            {
              kind: "label",
              text: ""
            },
            {
              kind: "block",
              type: "pixel_pixcolour",
            },
            {
              kind: "block",
              type: "pixel_vertcolour"
            }
          ],
        },
        {
          kind: "category",
          name: "Controls",
          colour: "#ffab19",
          contents: [
            {
              kind: "block",
              type: "control_if",
            },
            {
              kind: "block",
              type: "control_ifelse",
            },
            {
              kind: "block",
              type: "control_repeat",
              inputs: {
                times: {
                  shadow: {
                    type: "number_reporter",
                  },
                }
              }
            },
          ],
        },
        {
          kind: "category",
          name: "Operators",
          colour: "#59c059",
          contents: [
            {
              kind: "block",
              type: "operator_add",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_sub",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_mul",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_div",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_pow",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },

            {
              kind: "label",
              text: ""
            },

            {
              kind: "block",
              type: "operator_equalTo",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_notequalTo",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_lessThan",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_lessThanEqual",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_moreThan",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_moreThanEqual",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },

            {
              kind: "label",
              text: " "
            },

            {
              kind: "block",
              type: "operator_and",
            },
            {
              kind: "block",
              type: "operator_or",
            },
            {
              kind: "block",
              type: "operator_not",
            },

            {
              kind: "label",
              text: " "
            },

            {
              kind: "block",
              type: "operator_true",
            },
            {
              kind: "block",
              type: "operator_false",
            },

            {
              kind: "label",
              text: " "
            },
            {
              kind: "block",
              type: "operator_mod",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
                B: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
            {
              kind: "block",
              type: "operator_arith",
              inputs: {
                A: {
                  shadow: {
                    type: "number_reporter",
                  },
                },
              },
            },
          ],
        },
        {
          kind: "category",
          name: "Variables",
          colour: "#ff8c1a",
          contents: window.variableTypes
        }
      ],
    };
    workspace = Blockly.inject("BlocklyDiv", {
      toolbox: toolbox,
      collapse: false,
      comments: true,
      renderer: "zelos",
      plugins: {
        toolbox: window.ContinuousToolbox,
        flyoutsVerticalToolbox: window.ContinuousFlyout,
        metricsManager: window.ContinuousMetrics,
      },
      theme: penPlusBlocklyTheme(),
    });
    window.workspace = workspace;

    window.supportedEvents = new Set([
      Blockly.Events.BLOCK_CHANGE,
      Blockly.Events.BLOCK_CREATE,
      Blockly.Events.BLOCK_DELETE,
      Blockly.Events.BLOCK_MOVE,
    ]);

    // Add the disableOrphans event handler. This is not done automatically by
    // the plugin and should be handled by your application.
    workspace.addChangeListener(Blockly.Events.disableOrphans);

    workspace.addChangeListener(updateGLSL);

    workspace.registerButtonCallback("createVariable", () => {
      //Html Modal Mess
      createModal(`
        <div class="Modal" style="--ModalWidth:40%; --ModalHeight:auto; aspect-ratio:3/2;background-color: var(--EditorTheme_Theme_1);border-radius:1rem; filter: drop-shadow(0px 0px 5px white);">
          <div style="position:absolute;left:0px;top:0px; width:100%; height:40%; background-color: var(--EditorTheme_Theme_4);">
            <input placeholder="Variable Name" style="position:absolute;left:50%;top:50%;Transform:Translate(-50%,-50%); width:50%; height:20%;" type="text"></input>
            <p class="noSelect" style="position:absolute;left:50%;top:75%;Transform:Translate(-50%,-50%);font-family: 'Helvetica Neue', 'helvetica', serif; color:var(--EditorTheme_Text_2);">Only use A-Z</p>
          </div>
          <div class="noSelect" style="background-color: var(--EditorTheme_Color_1); width:100%; height:1.1em; position:absolute; font-family: 'Helvetica Neue', 'helvetica', serif; color:var(--EditorTheme_Text_3); text-align: center; justify-content: center; align-items: center;font-size: 2em;">
            Create Variable  
          </div>
          <div style="position:absolute; top:40%; width:100%; height:40%;font-family: 'Helvetica Neue', 'helvetica', serif; color:var(--EditorTheme_Text_1);">
            <p class="noSelect" style="position:absolute;left:50%;top:75%;Transform:Translate(-50%,-50%);font-family: 'Helvetica Neue', 'helvetica', serif; color:var(--EditorTheme_Text_2);">Variable Type</p>
            <!--Variable Types-->
            <div style="overflow-x:scroll; overflow-y:hidden; position:absolute; width:100%; height: 75%;text-align: center;">
              <!--Float-->
              <div style="position:absolute;background-color: var(--EditorTheme_Theme_3);border-radius:1em;width:auto;height:100%;aspect-ratio:7/6;justify-content: center;">
                <div style="background-color:#ff8c1a; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border-radius:100%; aspect-ratio:1; width:auto; height:50%;">
                </div>

                <p class="noSelect" style="position:absolute;top:85%;left:50%;transform:translate(-50%,-50%);font-size: 1.125em; width:50%; height:50%;">Float</p>
              </div>
              <!--Int-->
              <div style="left:25%; position:absolute;background-color: var(--EditorTheme_Theme_3);border-radius:1em;width:auto;height:100%;aspect-ratio:7/6; justify-content: center;">
                <div style="background-color:#ffde00;position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border-radius:100%; aspect-ratio:1; width:auto; height:50%;">
                </div>

                <p class="noSelect" style="position:absolute;top:85%;left:50%;transform:translate(-50%,-50%);font-size: 1.125em; width:50%; height:50%;">Int</p>
              </div>
              <!--Vec 2-->
              <div style="left:50%; position:absolute;background-color: var(--EditorTheme_Theme_3);border-radius:1em;width:auto;height:100%;aspect-ratio:7/6; justify-content: center;">
                <div style="background-color:#5AB897;position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border-radius:100%; aspect-ratio:1; width:auto; height:50%;">
                </div>

                <p class="noSelect" style="position:absolute;top:85%;left:50%;transform:translate(-50%,-50%);font-size: 1.125em; width:50%; height:50%;">Vector 2</p>
              </div>
              <!--Vec 3-->
              <div style="left:75%; position:absolute;background-color: var(--EditorTheme_Theme_3);border-radius:1em;width:auto;height:100%;aspect-ratio:7/6; justify-content: center;">
                <div style="background-color:#5BB4B7;position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border-radius:100%; aspect-ratio:1; width:auto; height:50%;">
                </div>

                <p class="noSelect" style="position:absolute;top:85%;left:50%;transform:translate(-50%,-50%);font-size: 1.125em; width:50%; height:50%;">Vector 3</p>
              </div>
              <!--Vec 4-->
              <div style="left:100%; position:absolute;background-color: var(--EditorTheme_Theme_3);border-radius:1em;width:auto;height:100%;aspect-ratio:7/6; justify-content: center;">
                <div style="background-color:#59BC77;position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border-radius:100%; aspect-ratio:1; width:auto; height:50%;">
                </div>

                <p class="noSelect" style="position:absolute;top:85%;left:50%;transform:translate(-50%,-50%);font-size: 1.125em; width:50%; height:50%;">Vector 4</p>
              </div>
              <!--Texture-->
              <div style="left:125%; position:absolute;background-color: var(--EditorTheme_Theme_3);border-radius:1em;width:auto;height:100%;aspect-ratio:7/6; justify-content: center;">
                <div style="background-color:#b464e7;position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border-radius:100%; aspect-ratio:1; width:auto; height:50%;">
                </div>

                <p class="noSelect" style="position:absolute;top:85%;left:50%;transform:translate(-50%,-50%);font-size: 1.125em; width:50%; height:50%;">Texture</p>
              </div>
              <!--Cubemap-->
              <div style="left:150%; position:absolute;background-color: var(--EditorTheme_Theme_3);border-radius:1em;width:auto;height:100%;aspect-ratio:7/6; justify-content: center;">
                <div style="background-color:#8672ff;position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border-radius:100%; aspect-ratio:1; width:auto; height:50%;">
                </div>

                <p class="noSelect" style="position:absolute;top:85%;left:50%;transform:translate(-50%,-50%);font-size: 1.125em; width:50%; height:50%;">Cubemap</p>
              </div>
              <!--Matrix-->
              <div style="left:175%; position:absolute;background-color: var(--EditorTheme_Theme_3);border-radius:1em;width:auto;height:100%;aspect-ratio:7/6; justify-content: center;">
                <div style="background-color:#737fff;position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border-radius:100%; aspect-ratio:1; width:auto; height:50%;">
                </div>

                <p class="noSelect" style="position:absolute;top:85%;left:50%;transform:translate(-50%,-50%);font-size: 1.125em; width:50%; height:50%;">Matrix</p>
              </div>
            </div>
            </div>
            <div style="top:80%;height:20%;width:100%;position:absolute;">
              <div>
                <div>
                  <input type="checkbox"></input>
                  <p>Uniform</p>
                </div>
              </div>
              <p class="noSelect" style="position:absolute;left:50%;top:20%;Transform:Translate(-50%,-50%);font-family: 'Helvetica Neue', 'helvetica', serif; color:var(--EditorTheme_Text_2);">Variable Scope</p>
            </div>
          </div>
        </div>
      `);
    })

    // The plugin must be initialized before it has any effect.
    const disableTopBlocksPlugin = new window.DisableTopBlocks();
    disableTopBlocksPlugin.init();
  }</script>
    <!--neato-->
  

</body>
                    </html>
                    